
 目录
最终的	N·萨基穆拉
 	NAT.Consulting（原为NRI）
 	J·布拉德利
 	Yubico（曾就职于 Ping Identity）
 	M·琼斯
 	自发行咨询（原为
 	微软）
 	B. 德梅德罗斯
 	谷歌
 	C. 莫蒂莫尔
 	迪士尼（曾就职于 Salesforce）
 	2023年12月15日

OpenID Connect Core 1.0 包含勘误表 2
抽象的
OpenID Connect 1.0 是 OAuth 2.0 协议之上的一个简单的身份层。它允许客户端基于授权服务器执行的身份验证来验证最终用户的身份，并以可互操作且类似 REST 的方式获取最终用户的基本个人资料信息。

本规范定义了 OpenID Connect 的核心功能：基于 OAuth 2.0 构建的身份验证，以及使用声明 (Claims) 传递最终用户信息。此外，本规范还描述了使用 OpenID Connect 的安全和隐私注意事项。


目录
1.  简介
    1.1.  要求符号和约定
    1.2.  术语
    1.3.  概述
2.   ID 令牌
3.  身份验证
    3.1.  使用授权码流程进行身份验证
        3.1.1.  授权码流程步骤
        3.1.2.  授权端点
            3.1.2.1.  身份验证请求
            3.1.2.2.  身份验证请求验证
            3.1.2.3.  授权服务器对最终用户进行身份验证
            3.1.2.4.  授权服务器获得最终用户同意/授权
            3.1.2.5.  成功的身份验证响应
            3.1.2.6.  身份验证错误响应
            3.1.2.7.  身份验证响应验证
        3.1.3.  令牌端点
            3.1.3.1.  令牌请求3.1.3.2
            .  令牌请求验证
            3.1.3.3.  成功的令牌响应
            3.1.3.4.  令牌错误响应
            3.1.3.5.  令牌响应验证
            3.1.3.6.   ID 令牌
            3.1.3.7.   ID 令牌验证
            3.1.3.8.  访问令牌验证
    3.2.  使用隐式流程进行身份验证
        3.2.1.  隐式流程步骤
        3.2.2.  授权端点
            3.2.2.1.身份  验证请求
            3.2.2.2.  身份验证请求验证
            3.2.2.3.  授权服务器对最终用户进行身份验证
            3.2.2.4.  授权服务器获得最终用户同意/授权
            3.2.2.5.  成功的身份验证响应
            3.2.2.6.  身份验证错误响应
            3.2.2.7.  重定向 URI 片段处理
            3.2.2.8.  身份验证响应验证
            3.2.2.9.  访问令牌验证
            3.2.2.10.   ID 令牌
            3.2.2.11.   ID 令牌验证
    3.3.  使用混合流程进行身份验证
        3.3.1.  混合流程步骤
        3.3.2.  授权端点
            3.3.2.1.  身份验证请求
            3.3.2.2.  身份验证请求验证
            3.3.2.3.  授权服务器对最终用户进行身份验证
            3.3.2.4.  授权服务器获得最终用户同意/授权
            3.3.2.5.  成功的身份验证响应
            3.3.2.6.  身份验证错误响应
            3.3.2.7.  重定向 URI 片段处理
            3.3.2.8.  身份验证响应验证
            3.3.2.9.  访问令牌验证
            3.3.2.10.  授权码验证
            3.3.2.11.   ID 令牌
            3.3.2.12.   ID 令牌验证
        3.3.3.  令牌端点
            3.3.3.1.  令牌请求
            3.3.3.2.  令牌请求验证
            3.3.3.3.  成功令牌响应
            3.3.3.4.  令牌错误响应
            3.3.3.5.  令牌响应验证
            3.3.3.6.   ID 令牌
            3.3.3.7.   ID 令牌验证
            3.3.3.8.  访问令牌
            3.3.3.9.  访问令牌验证
4.  从第三方发起登录
5.  声明
    5.1.  标准声明
        5.1.1.  地址声明
        5.1.2.  附加声明
    5.2.  声明语言和文字
    5.3.   UserInfo 端点
        5.3.1.   UserInfo 请求
        5.3.2.  成功的 UserInfo 响应
        5.3.3.   UserInfo 错误响应
        5.3.4.   UserInfo 响应验证
    5.4.  使用范围值请求声明
    5.5.  使用“claims”请求参数请求声明
        5.5.1.  单个声明请求
            5.5.1.1.  请求“acr”声明
        5.5.2.  单个声明的语言和文字
    5.6.  声明类型
        5.6.1.  正常声明
        5.6.2.  聚合和分布式声明
            5.6.2.1.  聚合声明示例
            5.6.2.2.  分布式声明示例
    5.7.  声明稳定性和唯一性
6.  将请求参数作为 JWT 传递
    6.1.  通过值传递请求对象
        6.1.1.  使用“request”请求参数的请求
    6.2.  通过引用传递请求对象
        6.2.1.  引用请求对象的 URI
        6.2.2.  使用“request_uri”请求参数的请求
        6.2.3.  授权服务器获取请求对象
        6.2.4.   “request_uri”的基本原理
    6.3.  验证基于 JWT 的请求
        6.3.1.  加密的请求对象
        6.3.2.  签名的请求对象
        6.3.3.  请求参数组装和验证
7.  自颁发 OpenID 提供商
    7.1.  自颁发 OpenID 提供商发现
    7.2.  自颁发 OpenID 提供商注册
        7.2.1.  使用“注册”请求参数提供信息
    7.3.  自颁发 OpenID 提供商请求
    7.4.  自颁发 OpenID 提供商响应
    7.5.  自颁发 ID 令牌验证
8.  主题标识符类型
    8.1.  成对标识符算法
9.  客户端身份验证
10.  签名和加密
    10.1.  签名
        10.1.1.  非对称签名密钥的轮换
    10.2.  加密
        10.2.1.  非对称加密密钥的轮换
11.  离线访问
12.  使用刷新令牌
    12.1.  刷新请求
    12.2.  成功刷新响应
    12.3.  刷新错误响应
13.  序列化
    13.1.  查询字符串序列化
    13.2.  表单序列化
    13.3.   JSON 序列化
14.  字符串操作
15.  实现注意事项
    15.1.  所有 OpenID 提供商必须实现的功能
    15.2.  动态 OpenID 提供商必须实现的功能
    15.3.  发现和注册
    15.4.  依赖方必须实现的功能
    15.5.  实现说明
        15.5.1.  授权码实现说明
        15.5.2.  随机数实现说明
        15.5.3.  重定向 URI 片段处理实现说明
    15.6.  兼容性说明
    15.7.  相关规范和实现者指南
16.  安全注意事项
    16.1.  请求披露
    16.2.  服务器伪装
    16.3.  令牌制造/修改
    16.4.  访问令牌泄露
    16.5.  服务器响应泄露
    16.6.  服务器响应否认
    16.7.  请求否认
    16.8.  访问令牌重定向
    16.9.  令牌重用
    16.10.  窃听或泄露授权码 (二次认证器捕获)
    16.11.  令牌替换
    16.12.  计时攻击
    16.13.  其他加密相关攻击
    16.14.  签名和加密顺序
    16.15.  发行者标识符
    16.16.  隐式流威胁
    16.17.   TLS 要求
    16.18.  访问令牌和刷新令牌的生命周期
    16.19.  对称密钥熵
    16.20.  需要签名的请求
    16.21.  需要加密的请求
    16.22.   HTTP 307 重定向
    16.23.   iOS 上的自定义 URI 方案
17.  隐私注意事项
    17.1.  个人身份信息
    17.2.  数据访问监控
    17.3.  相关性
    17.4.  离线访问
18.   IANA 注意事项
    18.1.   JSON Web 令牌声明注册
        18.1.1.  注册表内容
    18.2.   OAuth 参数注册
        18.2.1.  注册表内容
    18.3.   OAuth 扩展错误注册
        18.3.1.  注册表内容
    18.4.   URI 方案注册
        18.4.1.  注册表内容
19.  参考文献
    19.1.  规范性参考文献
    19.2.  参考文献
附录 A.  授权示例
    A.1.  使用response_type=code的示例
    A.2.  使用response_type=id_token的示例
    A.3.  使用response_type=id_token token的示例
    A.4.  使用response_type=code id_token的示例
    A.5.  使用response_type=code token的示例
    A.6.  使用response_type=code id_token token的示例
    A.7.  示例中使用的RSA密钥
附录 B.  致谢
附录 C.  声明
§  作者地址



 目录
1. 简介
OpenID Connect 1.0 是基于 OAuth 2.0 [RFC6749] 协议的简单身份层。它允许客户端基于授权服务器执行的身份验证来验证最终用户的身份，并以可互操作且类似 REST 的方式获取最终用户的基本个人资料信息。

OpenID Connect Core 1.0 规范定义了 OpenID Connect 的核心功能：基于 OAuth 2.0 构建的身份验证，以及使用声明来传递最终用户的信息。它还描述了使用 OpenID Connect 的安全和隐私注意事项。

作为背景，OAuth 2.0 授权框架[RFC6749] 和OAuth 2.0 持有者令牌使用[RFC6750] 规范为第三方应用程序获取和使用 HTTP 资源的有限访问权限提供了一个通用框架。它们定义了获取和使用访问令牌访问资源的机制，但没有定义提供身份信息的标准方法。值得注意的是，如果不对 OAuth 2.0 进行性能分析，它就无法提供有关最终用户身份验证的信息。希望读者熟悉这些规范。

OpenID Connect 将身份验证作为 OAuth 2.0 授权流程的扩展来实现。客户端通过在授权请求中包含openid范围值来请求使用此扩展。已执行身份验证的信息将以JSON Web 令牌 (JWT) [JWT] 的形式返回，该令牌称为 ID 令牌（请参阅第 2 节）。实现 OpenID Connect 的 OAuth 2.0 身份验证服务器也称为 OpenID 提供商 (OP)。使用 OpenID Connect 的 OAuth 2.0 客户端也称为依赖方 (RP)。

本规范假定依赖方已获取 OpenID 提供者的配置信息，包括其授权端点和令牌端点的位置。这些信息通常通过发现机制获取，如OpenID Connect 发现 1.0 [OpenID.Discovery] 中所述，或者也可以通过其他机制获取。

同样，本规范假定依赖方已获得足够的凭证并提供使用 OpenID 提供者所需的信息。这通常通过动态注册完成，如 OpenID Connect 动态客户端注册 1.0 [OpenID.Registration] 中所述，或者也可以通过其他机制获取。

本规范的先前版本为：

OpenID Connect Core 1.0 包含勘误表 1 [OpenID.Core.Errata1]
OpenID Connect Core 1.0（最终版） [OpenID.Core.Final]


 目录
1.1. 需求符号和约定
本文档中的关键词“必须”、“不得”、“要求”、“应该”、“不应”、“应该”、“不应该”、“推荐”、“不推荐”、“可以”和“可选”应按照RFC 2119 [RFC2119] 中的描述进行解释。

在本规范的 .txt 版本中，值会被引号括起来，以表明应按字面意思理解。在协议消息中使用这些值时，引号不得作为值的一部分。在本规范的 HTML 版本中，应按字面意思理解的值会使用等宽字体来表示。

本规范中所有JSON Web 签名 (JWS) [JWS] 和JSON Web 加密 (JWE) [JWE] 数据结构的使用均采用 JWS 紧凑序列化或 JWE 紧凑序列化；不使用 JWS JSON 序列化和 JWE JSON 序列化。


 目录
1.2. 术语
本规范使用 OAuth 2.0 [RFC6749] 定义的术语“访问令牌”、“授权码”、“授权端点”、“授权授予”、“授权服务器”、“客户端”、“客户端身份验证”、“客户端标识符”、“客户端密钥”、“授予类型”、“受保护资源”、“重定向 URI”、“刷新令牌”、“资源服务器”、“响应类型”和“令牌端点”，JSON Web 令牌 (JWT) [JWT] 定义的术语“声明名称”、“声明值”、“JSON Web 令牌 (JWT)”、“JWT 声明集”和“嵌套 JWT” ， JSON Web 签名 (JWS) [ JWS] 定义的术语“Base64url 编码”、“标头参数”和“JOSE 标头” ， RFC 7230 [RFC7230] 定义的术语“用户代理” ，以及 OAuth 2.0 多响应类型定义的术语“响应模式”。编码实践[OAuth.Responses]。

本规范还定义了以下术语：

验证
用于对实体和所呈现的身份之间的绑定实现足够信心的过程。
身份验证请求
OAuth 2.0 授权请求使用 OpenID Connect 定义的扩展参数和范围来请求最终用户通过授权服务器（OpenID Connect 提供商）向客户端（OpenID Connect 依赖方）进行身份验证。
身份验证上下文
依赖方在针对身份验证响应做出授权决策之前可能需要的信息。此类上下文可以包括但不限于实际使用的身份验证方法或认证保证级别，例如 ISO/IEC 29115 [ISO29115] 实体身份验证保证级别。
身份验证上下文类
在特定环境下被认为彼此等同的一组身份验证方法或程序。
身份验证上下文类参考
身份验证上下文类的标识符。
授权码流程
OAuth 2.0 流程，其中授权码从授权端点返回，所有令牌从令牌端点返回。
授权请求
[RFC6749] 定义的 OAuth 2.0 授权请求。
宣称
关于实体的断言信息。
索赔类型
用于表示声明值的语法。本规范定义了普通、聚合和分布式声明类型。
索赔提供者
可以返回有关实体的声明的服务器。
凭据
作为使用身份或其他资源的权利证据而呈现的数据。
终端用户
人类参与者。
实体
具有独立且独特存在，且可在特定上下文中识别的事物。最终用户就是实体的一个例子。
基本主张
客户指定的声明对于确保最终用户请求的特定任务的授权体验顺利进行是必要的。
混合流
OAuth 2.0 流程，其中从授权端点返回授权码，从授权端点返回一些令牌，从令牌端点返回其他令牌。
ID 令牌
JSON Web Token (JWT) [JWT] 包含有关身份验证事件的声明。它可能包含其他声明。
标识符
在特定上下文中唯一地表征实体的值。
身份
与实体相关的属性集。
隐式流
OAuth 2.0 流程中所有令牌均从授权端点返回，并且不使用令牌端点或授权码。
发行人
发出一组索赔的实体。
发卡机构标识符
可验证的发行者标识符。发行者标识符是一个区分大小写的 URL，使用https方案，包含方案、主机名以及可选的端口号和路径部分，但不包含查询或片段部分。
信息
OpenID 依赖方和 OpenID 提供者之间的请求或响应。
OpenID 提供商 (OP)
OAuth 2.0 授权服务器能够对最终用户进行身份验证，并向依赖方提供有关身份验证事件和最终用户的声明。
请求对象
JWT 包含一组请求参数作为其声明。
请求 URI
引用包含请求对象的资源的 URL。授权服务器必须能够检索请求 URI 的内容。
成对假名标识符 (PPID)
向依赖方标识实体的标识符，该标识符不能与另一个依赖方的实体的 PPID 关联。
个人身份信息（PII）
信息（a）可用于识别与该信息相关的自然人，或（b）与与该信息相关的自然人有或可能有直接或间接关联。
依赖方（RP）
OAuth 2.0 客户端应用程序需要来自 OpenID 提供商的最终用户身份验证和声明。
扇区标识符
依赖方组织使用的 URL 的主机组件，它是该依赖方成对主题标识符计算的输入。
自发行 OpenID 提供商
个人、自托管的 OpenID 提供商，发布自签名的 ID 令牌。
主题标识符
发行方为最终用户提供的本地唯一且永不重新分配的标识符，旨在供客户使用。
用户信息端点
受保护的资源，当客户端提供访问令牌时，将返回由相应授权许可所代表的最终用户的授权信息。UserInfo 端点 URL 必须使用https方案，并且可以包含端口、路径和查询参数。
验证
旨在确定构造的健全性或正确性的过程。
确认
旨在测试或证明事实或价值的真实性或准确性的过程。
自愿申领
客户指定的声明对于最终用户请求的特定任务有用但并非必不可少。

致读者重要提示：本节中的术语定义是本规范的规范性部分，对实现提出了要求。本规范文本中所有大写单词，例如“发行者标识符”，均指这些定义的术语。读者在遇到这些术语时，必须遵循本节中的定义。

有关所用术语的更多背景信息，请参阅《互联网安全术语表》第 2 版[RFC4949]、 ISO/IEC 29115 实体身份验证保证[ISO29115] 和ITU-T X.1252 [X.1252]。


 目录
1.3. 概述
OpenID Connect 协议抽象来说遵循以下步骤。


RP（客户端）向 OpenID 提供商（OP）发送请求。
OP 对最终用户进行身份验证并获得授权。
OP 使用 ID 令牌和通常的访问令牌进行响应。
RP 可以向 UserInfo Endpoint 发送带有访问令牌的请求。
UserInfo Endpoint 返回有关最终用户的声明。

下图说明了这些步骤：

+--------+ +--------+
| | | |
| |---------(1) AuthN 请求-------->| |
| | | |
| | +--------+ | |
| | | | | |
| | |结束- |<--(2) AuthN 和 AuthZ-->| |
| | | 用户 | | |
| RP | | | | OP |
| | +--------+ | |
| | | |
| |<--------(3) AuthN 响应--------| |
| | | |
| |---------(4) 用户信息请求----->| |
| | | |
| |<--------(5) UserInfo 响应-----| |
| | | |
+--------+ +--------+

 目录
2. ID 令牌
OpenID Connect 对 OAuth 2.0 进行的主要扩展是 ID Token 数据结构，以便最终用户能够进行身份验证。ID Token 是一种安全令牌，它包含授权服务器在使用客户端时对最终用户进行身份验证的声明，以及其他可能请求的声明。ID Token 以 JSON Web Token (JWT) [JWT] 的形式表示。

OpenID Connect 使用的所有 OAuth 2.0 流的 ID 令牌中均使用以下声明：


国际空间站
必需。响应的发行者标识符。iss值是一个区分大小写的 URL，使用https方案，包含方案、主机名以及可选的端口号和路径部分，但不包含查询或片段部分。
潜艇
必填项。主体标识符。发卡机构内部为最终用户提供的本地唯一且永不重新分配的标识符，供客户端使用，例如24400320 或AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4 。其长度不得超过 255 个 ASCII [RFC20]字符。sub值区分大小写。
澳元
必需。此 ID 令牌的目标受众。它必须包含 依赖方的OAuth 2.0 client_id作为受众值。它也可以包含其他受众的标识符。通常情况下， aud值是一个区分大小写的字符串数组。在常见的特殊情况下，当只有一个受众时，aud值可以是一个区分大小写的字符串。
经验值
必填项。ID 令牌在此到期时间或之后，RP 与 OP 进行身份验证时不得接受该 ID 令牌。处理此参数时，要求当前日期/时间必须早于值中列出的到期日期/时间。实施者可以预留一些余地，通常不超过几分钟，以应对时钟偏差。其值是一个 JSON [RFC8259]数字，表示从 1970-01-01T00:00:00Z 到该日期/时间的秒数（以 UTC 为单位）。有关日期/时间（尤其是 UTC）的详细信息，请参阅RFC 3339 [RFC3339]。注意：ID 令牌到期时间与 RP 和 OP 之间已验证会话的生命周期无关。
iat
必需。JWT 签发时间。其值是一个 JSON 数字，表示从 1970-01-01T00:00:00Z 到该日期/时间的秒数（以 UTC 时间计算）。
授权时间
最终用户身份验证发生的时间。其值是一个 JSON 数字，表示从 1970-01-01T00:00:00Z（以 UTC 为单位）到该日期/时间的秒数。当发出max_age请求或将auth_time作为必需声明时，此声明为必需；否则，可选择性地包含。（auth_time声明在语义上对应于 OpenID 2.0 PAPE [OpenID.PAPE] 的 auth_time响应参数。）
随机数
用于将客户端会话与 ID 令牌关联，并用于缓解重放攻击的字符串值。该值未经修改地从身份验证请求传递到 ID 令牌。如果 ID 令牌中存在nonce声明值，客户端必须验证该值是否等于 身份验证请求中发送的nonce参数值。如果身份验证请求中存在 nonce 声明值，授权服务器必须在 ID 令牌中包含nonce声明，其声明值应为身份验证请求中发送的 nonce 值。授权服务器不应对该nonce值进行任何其他处理。nonce值是区分大小写的字符串。
乙酰胆碱
可选。身份验证上下文类引用。该字符串指定一个身份验证上下文类引用值，用于标识所执行身份验证所满足的身份验证上下文类。值“0”表示最终用户身份验证不符合 ISO/IEC 29115 [ISO29115] 级别 1 的要求。由于历史原因，值“0”用于表示无法确定是否为同一人。级别 0 的身份验证不应用于授权访问任何具有货币价值的资源。（这对应于 OpenID 2.0 PAPE [OpenID.PAPE] nist_auth_level 0。）应使用绝对 URI 或RFC 6711 [RFC6711] 注册名称作为 acr值；注册名称的含义不得与注册名称不同。使用此声明的各方需要就所用值的含义达成一致，这些含义可能与具体情况相关。 acr值是区分大小写的字符串 。
安博
可选。身份验证方法参考。JSON 字符串数组，用于标识身份验证中使用的身份验证方法。例如，值可能指示同时使用了密码和 OTP 身份验证方法。amr值是一个区分大小写的字符串数组。amr 声明中使用的值 应来自由[RFC8176] 建立的IANA 身份验证方法参考值注册表[IANA.AMR]中注册的值；使用此声明的各方需要就任何未注册值的含义达成一致，这些含义可能与具体情况相关。
azp
可选。授权方 - ID 令牌签发给的一方。如果存在，则必须包含该方的 OAuth 2.0 客户端 ID。azp值是一个区分大小写的字符串，包含一个 StringOrURI 值。请注意，实际上，azp声明仅在使用超出本规范范围的扩展时才会发生；因此，建议未使用此类扩展的实现不要使用azp ，并在出现 azp 时忽略它。

ID 令牌可以包含其他声明。任何未理解的声明都必须被忽略。 有关本规范定义的其他声明， 请参阅第 3.1.3.6节、 第 3.3.2.11节、 第 5.1 节和 第 7.4节。

ID 令牌必须使用JWS [JWS] 进行签名，也可以选择分别使用JWS [JWS] 和JWE [JWE] 进行签名和加密，从而提供身份验证、完整性、不可否认性以及可选的机密性，如第 16.14 节所述。如果 ID 令牌已加密，则必须先签名再加密，结果为嵌套 JWT，定义见[JWT]。ID 令牌不得使用none 作为alg值，除非使用的响应类型从授权端点未返回 ID 令牌（例如使用授权码流程时），并且客户端在注册时 明确请求使用 none 。

ID 令牌不应使用 JWS 或 JWE 的 x5u、 x5c、 jku或 jwk标头参数字段。相反，应根据第 10 节 的规定，使用发现和注册参数提前传达所用密钥的引用。

以下是 ID 令牌中的声明集（JWT 声明集）的非规范示例：

  {
   "iss": "https://server.example.com",
   "sub": "24400320",
   "aud": "s6BhdRkqt3",
   “nonce”：“n-0S6_WzA2Mj”，
   "exp": 1311281970,
   “iat”：1311280970，
   “授权时间”：1311280969，
   “acr”：“urn：mace：incommon：iap：silver”
  }

 目录
3. 身份验证
OpenID Connect 执行身份验证，用于帮助最终用户登录或确定最终用户已登录。OpenID Connect 将服务器执行的身份验证结果以安全的方式返回给客户端，以便客户端可以依赖该结果。因此，在这种情况下，客户端被称为依赖方 (RP)。

身份验证结果以 ID 令牌的形式返回，定义见第 2 节。该令牌包含声明，用于表达诸如颁发者、主体标识符、身份验证执行时间等信息。

身份验证可以遵循以下三种路径之一：授权码流程（response_type=code）、隐式流程（response_type=id_token token 或request_type=id_token）或混合流程（使用 OAuth 2.0 多响应类型编码实践[OAuth.Responses] 中定义的其他响应类型值）。这些流程决定了如何将 ID 令牌和访问令牌返回给客户端。

以下非规范性表格总结了这三种流程的特点。该表旨在为在特定情况下选择哪种流程提供一些指导。


财产	授权码流程	隐式流	混合流
从授权端点返回的所有令牌	不	是的	不
从 Token Endpoint 返回的所有令牌	是的	不	不
令牌未透露给用户代理	是的	不	不
客户端可以通过身份验证	是的	不	是的
可以刷新令牌	是的	不	是的
一次往返即可沟通	不	是的	不
大多数通信都是服务器到服务器	是的	不	各不相同

 OpenID Connect 身份验证流程
使用的流程由授权请求中包含的response_type值 决定。这些response_type值用于选择以下流程：


“response_type”值	流动
代码 	授权码流程
id_token 	隐式流
id_token 令牌 	隐式流
代码 id_token 	混合流
代码令牌 	混合流
代码 id_token 令牌 	混合流

 OpenID Connect“response_type”值
除了OAuth 2.0 [RFC6749]定义的代码响应类型值外， 其他所有值均在OAuth 2.0 多响应类型编码实践[OAuth.Responses] 规范中定义 。注意：虽然 OAuth 2.0 也为隐式流程定义了 令牌响应类型值，但 OpenID Connect 不使用此响应类型，因为不会返回 ID 令牌。


 目录
3.1. 使用授权码流程进行身份验证
本节介绍如何使用授权码流程执行身份验证。使用授权码流程时，所有令牌均从令牌端点返回。

授权码流程会将授权码返回给客户端，客户端可以直接将其兑换为 ID 令牌和访问令牌。这样做的好处是不会将任何令牌暴露给用户代理，也不会暴露给其他可能访问该用户代理的恶意应用程序。授权服务器还可以在将授权码兑换为访问令牌之前对客户端进行身份验证。授权码流程适用于能够在自身和授权服务器之间安全地维护客户端密钥的客户端。


 目录
3.1.1. 授权码流程步骤
授权码流程经过以下步骤。


客户端准备包含所需请求参数的身份验证请求。
客户端向授权服务器发送请求。
授权服务器对最终用户进行身份验证。
授权服务器获得最终用户的同意/授权。
授权服务器将最终用户连同授权码一起发回给客户端。
客户端使用令牌端点处的授权码请求响应。
客户端收到响应，响应主体中包含 ID 令牌和访问令牌。
客户端验证 ID 令牌并检索最终用户的主题标识符。


 目录
3.1.2. 授权端点
授权端点负责对最终用户进行身份验证。具体方法是将用户代理发送到授权服务器的授权端点进行身份验证和授权，使用 OAuth 2.0 定义的请求参数以及 OpenID Connect 定义的附加参数和参数值。

与授权端点的通信必须使用 TLS。有关使用 TLS 的更多信息， 请参阅第 16.17 节。


 目录
3.1.2.1. 认证请求
身份验证请求是 OAuth 2.0 授权请求，请求授权服务器对最终用户进行身份验证。

授权服务器必须支持在授权端点使用RFC 7231 [RFC7231]中定义的HTTP GET和 POST方法。客户端可以使用 HTTP GET或 POST方法向授权服务器发送授权请求。如果使用 HTTP GET方法，则请求参数将使用 URI 查询字符串序列化进行序列化，具体请参见第 13.1 节。如果使用 HTTP POST 方法，则请求参数将使用表单序列化进行序列化，具体请参见第 13.2 节。

OpenID Connect 在授权码流中使用以下 OAuth 2.0 请求参数：


范围
必需。OpenID Connect 请求必须包含openid范围值。如果openid范围值不存在，则行为完全未指定。其他范围值可以存在。如果实现无法理解，则应忽略所使用的范围值。 有关本规范定义的其他范围值， 请参阅第 5.4节 和第 11节。
响应类型
必需。OAuth 2.0 响应类型值，用于确定要使用的授权处理流程，包括从所用端点返回的参数。使用授权码流程时，此值为 code。
客户端 ID
必需。授权服务器上有效的 OAuth 2.0 客户端标识符。
重定向uri
必需。响应将被发送到的重定向 URI。此 URI 必须与客户端在 OpenID 提供商处预先注册的重定向 URI 值之一完全匹配，匹配过程按照[RFC3986]第 6.2.1 节（简单字符串比较）中的说明执行。使用此流程时，重定向 URI 应该使用https方案；但是，如果客户端类型为 保密类型（定义见 OAuth 2.0 第 2.1 节），并且 OP 允许 在这种情况下使用http重定向 URI，则可以使用http方案。此外，如果客户端是原生应用，它可以使用http方案，并使用 localhost或 IP 环回字符串 127.0.0.1或[::1] 作为主机名。重定向 URI 可以使用其他方案，例如用于标识原生应用回调的方案。
状态
推荐使用。用于维护请求和回调之间的状态的不透明值。通常，跨站请求伪造 (CSRF、XSRF) 防护是通过将此参数的值与浏览器 Cookie 加密绑定来实现的。

OpenID Connect 还使用以下 OAuth 2.0 请求参数，该参数在 OAuth 2.0 多响应类型编码实践[OAuth.Responses] 中定义：


响应模式
可选。告知授权服务器从授权端点返回参数的机制。当请求的响应模式为响应类型指定的默认模式时，不建议使用此参数。

本规范还定义了以下请求参数：


随机数
可选。用于将客户端会话与 ID 令牌关联起来并缓解重放攻击的字符串值。该值会原封不动地从身份验证请求传递到 ID 令牌。nonce 值必须具有足够的熵， 以防止攻击者猜测值。有关实现说明，请参阅第 15.5.2 节。
展示
可选。ASCII 字符串值，用于指定授权服务器如何向最终用户显示身份验证和同意用户界面页面。定义的值如下：
页
授权服务器应显示与完整用户代理页面视图一致的身份验证和同意 UI。如果未指定 display 参数，则此为默认显示模式。
弹出窗口
授权服务器应显示与弹出式用户代理窗口一致的身份验证和同意 UI。弹出式用户代理窗口的大小应适合登录对话框，并且不应遮挡弹出窗口的整个窗口。
触碰
授权服务器应该显示与利用触摸界面的设备一致的身份验证和同意 UI。
无线应用软件
授权服务器应该显示与“功能手机”类型显示一致的身份验证和同意 UI。
授权服务器还可以尝试检测用户代理的功能并提供适当的显示。
如果 OP 收到一个超出上述定义集合且它无法理解的 显示值，它可能会返回错误或者忽略它；实际上，不返回无法理解的值的错误将有助于使用新的显示值逐步引入扩展。
迅速的
可选。空格分隔、区分大小写的 ASCII 字符串列表，用于指定授权服务器是否提示最终用户重新进行身份验证和同意。定义的值如下：
没有任何
授权服务器不得显示任何身份验证或同意用户界面页面。如果最终用户尚未通过身份验证，或者客户端未预先配置对所请求声明的同意，或者未满足处理请求的其他条件，则会返回错误。错误代码通常为 login_required、 interact_required或第 3.1.2.6 节中定义的其他代码。这可用于检查是否存在身份验证和/或同意。
登录
授权服务器应该提示最终用户重新进行身份验证。如果无法重新验证最终用户，则必须返回错误，通常是login_required。
同意
授权服务器应该在向客户端返回信息之前提示最终用户同意。如果无法获得同意，则必须返回错误，通常是“consent_required”。
选择账户
授权服务器应该提示最终用户选择一个用户帐户。这使得在授权服务器上拥有多个帐户的最终用户能够在当前会话可能关联的多个帐户中进行选择。如果无法获取最终用户的帐户选择信息，则必须返回错误，通常为account_selection_required。
客户端可以使用prompt 参数来确认最终用户仍在当前会话中，或提醒用户注意此请求。如果此参数包含none 或其他值，则会返回错误。
如果 OP 收到超出上述定义集合的它无法理解的提示值，它可能会返回错误或者忽略它；实际上，不返回无法理解的值的错误将有助于使用新的 提示值逐步引入扩展。
最大年龄
可选。最大身份验证时长。指定自上次最终用户被 OP 主动身份验证以来允许的经过时间（以秒为单位）。如果经过时间大于此值，OP 必须尝试主动重新验证最终用户。（max_age请求参数对应于 OpenID 2.0 PAPE [OpenID.PAPE] max_auth_age请求参数。）使用max_age时，返回的 ID 令牌必须包含auth_time声明值。注意，max_age=0等同于prompt=login。
ui_locales
可选。最终用户在用户界面中使用的首选语言和文字，以空格分隔的BCP47 [RFC5646] 语言标签值 列表表示 ，并按优先顺序排列。例如，值“fr-CA fr en”表示优先使用加拿大法语，其次是法语（不带地区标识），最后是英语（不带地区标识）。如果 OpenID 提供商不支持部分或全部请求的区域设置，则不应导致错误。
id_token_hint
可选。授权服务器先前签发的 ID 令牌将作为提示传递，提示最终用户当前或过去与客户端的身份验证会话。如果 ID 令牌标识的最终用户已登录或已根据请求登录（OP 可能会评估 ID 令牌以外的其他信息来做出此决定），则授权服务器返回肯定响应；否则，必须返回错误，例如login_required。如果可能，在使用prompt=none 时应该存在id_token_hint ，如果不存在，则可以返回invalid_request错误；但是，即使不存在，服务器也应该尽可能成功响应。当 ID 令牌用作 id_token_hint值时，授权服务器无需列为 ID 令牌的受众。
如果 RP 从 OP 收到的 ID 令牌已加密，为了将其用作id_token_hint，客户端必须解密加密 ID 令牌中包含的签名 ID 令牌。客户端可以使用密钥将签名的 ID 令牌重新加密并发送给身份验证服务器，该密钥允许服务器解密 ID 令牌，并将重新加密的 ID 令牌用作 id_token_hint 的值。
登录提示
可选。提示授权服务器最终用户可能用于登录的登录标识符（如有必要）。如果授权服务器首先询问最终用户的电子邮件地址（或其他标识符），然后希望将该值作为提示传递给已发现的授权服务，则可以使用此提示。建议提示值与用于发现的值匹配。此值也可以是 phone_number 声明中指定格式的电话号码。此参数的使用由授权服务器 (OP) 自行决定。
acr_值
可选。请求的身份验证上下文类参考值。该参数为空格分隔的字符串， 用于指定授权服务器处理此身份验证请求时使用的acr值，这些值按优先顺序排列。执行的身份验证所满足的身份验证上下文类将作为acr声明值返回，具体定义见第 2 节。此参数将acr声明作为自愿声明请求。

可以发送其他参数。 有关本规范定义的其他授权请求参数和参数值， 请参阅第 3.2.2节、 3.3.2 节、 5.2 节、 5.5 节、 6 节和 7.2.1节。

以下是客户端的非规范示例 HTTP 302 重定向响应，它触发用户代理向授权端点发出身份验证请求（值内的换行符仅为了显示目的）：

  HTTP/1.1 302 已找到
  位置：https://server.example.com/authorize?
    响应类型=代码
    &scope=openid%20profile%20email
    &客户端 ID=s6BhdRkqt3
    &state=af0ifjsldkj
    &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb
以下是用户代理响应上述客户端的 HTTP 302 重定向响应而发送给授权服务器的非规范示例请求（值内的换行符仅为了显示目的）：

  获取/授权？
    响应类型=代码
    &scope=openid%20profile%20email
    &客户端 ID=s6BhdRkqt3
    &state=af0ifjsldkj
    &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb HTTP/1.1
  主机：server.example.com

 目录
3.1.2.2. 身份验证请求验证
授权服务器必须验证收到的请求如下：


授权服务器必须根据 OAuth 2.0 规范验证所有 OAuth 2.0 参数。
验证scope参数是否存在且包含openid scope 值。（如果不存在openid scope 值，则该请求可能仍然是有效的 OAuth 2.0 请求，但不是 OpenID Connect 请求。）
授权服务器必须验证所有必需参数是否存在以及它们的使用是否符合此规范。
如果请求的子声明（subject）中包含 ID 令牌的特定值，授权服务器必须仅在该子值所标识的最终用户与授权服务器有活动会话或已通过该请求的身份验证时才发送肯定响应。授权服务器不得使用其他用户的 ID 令牌或访问令牌进行回复，即使该用户与授权服务器有活动会话。此类请求可以使用 id_token_hint参数发出，也可以通过请求第 5.5.1 节中所述的特定声明值（如果实现支持 claims参数）来发出。
当id_token_hint存在时，OP 必须验证其是否为该 ID Token 的签发者。即使有效期已过，当 ID Token 所标识的 RP 当前正在会话或最近与 OP 有过会话时，OP 也应该接受该 ID Token。

根据OAuth 2.0 [RFC6749] 中的规定，授权服务器应该忽略无法识别的请求参数。

如果授权服务器遇到任何错误，它必须按照第 3.1.2.6 节 返回错误响应。


 目录
3.1.2.3. 授权服务器验证最终用户
如果请求有效，授权服务器将尝试对最终用户进行身份验证，或根据所使用的请求参数值确定最终用户是否已通过身份验证。授权服务器用于对最终用户进行身份验证的方法（例如用户名和密码、会话 Cookie 等）不在本规范的讨论范围内。授权服务器可能会显示身份验证用户界面，具体取决于所使用的请求参数值和所使用的身份验证方法。

在以下情况下，授权服务器必须尝试对最终用户进行身份验证：

最终用户尚未经过身份验证。
身份验证请求包含值为 login 的prompt参数。在这种情况下，即使最终用户已经通过身份验证，授权服务器也必须重新验证最终用户。

在以下情况下，授权服务器不得与最终用户交互：

身份验证请求包含值为 none 的prompt参数。在这种情况下，如果最终用户尚未完成身份验证或无法静默完成身份验证，授权服务器必须返回错误。

与最终用户交互时，授权服务器必须采取适当的措施来防止跨站请求伪造和点击劫持，如OAuth 2.0 [RFC6749] 第 10.12 和 10.13 节所述。


 目录
3.1.2.4. 授权服务器获得最终用户的同意/授权
一旦最终用户通过身份验证，授权服务器必须先获得授权决策，然后才能向依赖方发布信息。如果请求参数允许，授权决策可以通过与最终用户进行交互式对话来完成，该对话应明确最终用户的同意内容，或者通过处理请求的条件或其他方式（例如，通过事先获得管理同意）来建立最终用户的同意。第 2节和 第 5.3节描述了信息发布机制。


 目录
3.1.2.5. 成功认证响应
身份验证响应是 OP 的授权端点响应 RP 发送的授权请求消息而返回的 OAuth 2.0 授权响应消息。

使用授权码流程时，授权响应必须返回OAuth 2.0 [RFC6749] 第 4.1.2 节中定义的参数， 方法是将它们作为查询参数添加到授权请求中指定的redirect_uri ，使用application/x-www-form-urlencoded格式，除非指定了不同的响应模式。

以下是使用此流程的非规范示例成功响应（值内的换行仅用于显示目的）：

  HTTP/1.1 302 已找到
  位置：https://client.example.org/cb?
    代码=SplxlOBeZQQYbYS6WxSbIA
    &state=af0ifjsldkj
有关授权码内容的实施说明，请参阅第 15.5.1 节。


 目录
3.1.2.6. 认证错误响应
身份验证错误响应是 OP 的授权端点响应 RP 发送的授权请求消息而返回的 OAuth 2.0 授权错误响应消息。

如果最终用户拒绝请求或最终用户身份验证失败，OP（授权服务器）将使用OAuth 2.0 [RFC6749] 第 4.1.2.1 节中定义的错误响应参数通知 RP（客户端）。（与 RFC 6749 无关的 HTTP 错误将使用相应的 HTTP 状态代码返回给用户代理。）

除非重定向 URI 无效，否则授权服务器会将客户端返回到授权请求中指定的重定向 URI，并附带相应的错误和状态参数。不应返回其他参数。如果重定向 URI 无效，授权服务器不得将用户代理重定向到无效的重定向 URI。

如果不支持响应模式值，授权服务器将返回 HTTP 响应代码 400（错误请求），不带错误响应参数，因为了解响应模式对于知道如何返回这些参数是必要的。

除了OAuth 2.0第4.1.2.1节定义的错误码外，本规范还定义了以下错误码：


交互必需
授权服务器需要某种形式的最终用户交互才能继续进行。当 身份验证请求中的提示参数值为none时，可能会返回此错误，但如果不显示最终用户交互的用户界面，则身份验证请求无法完成。
需要登录
授权服务器需要最终用户身份验证。当 身份验证请求中的提示参数值为none时，可能会返回此错误，但如果不显示最终用户身份验证的用户界面，则身份验证请求无法完成。
account_selection_required
最终用户必须在授权服务器上选择一个会话。最终用户可以在授权服务器上使用不同的关联账户进行身份验证，但最终用户未选择会话。当身份验证请求中的提示参数值为none 时，可能会返回此错误，但如果身份验证请求未显示用户界面提示用户选择要使用的会话，则无法完成身份验证请求。
需要同意
授权服务器需要最终用户的同意。当 身份验证请求中的提示参数值为none时，可能会返回此错误，但如果不显示用户界面以征求最终用户的同意，则身份验证请求无法完成。
无效的请求 uri
授权请求中的 request_uri 返回 错误或包含无效数据。
无效的请求对象
请求 参数 包含无效的请求对象。
请求不受支持
OP 不支持使用 第 6 节中定义的请求参数。
request_uri_not_supported
OP 不支持使用 第 6 节中定义的request_uri参数。
不支持注册
OP 不支持使用 第 7.2.1 节中定义的注册参数。

错误响应参数如下：

错误
必需。错误代码。
错误描述
可选。错误的人类可读的 ASCII 编码文本描述。
错误 uri
可选。包含有关错误的附加信息的网页的 URI。
状态
OAuth 2.0 状态值。如果授权请求包含state参数，则此字段为必填项。设置为从客户端收到的值。

使用授权码流时，错误响应参数将添加到重定向 URI 的查询组件中，除非指定了不同的响应模式。


以下是使用此流程的非规范示例错误响应（值内的换行仅用于显示目的）：

  HTTP/1.1 302 已找到
  位置：https://client.example.org/cb?
    错误=无效请求
    &错误描述=
      不支持的%20response_type%20值
    &state=af0ifjsldkj

 目录
3.1.2.7. 身份验证响应验证
使用授权码流程时，客户端必须根据 RFC 6749（尤其是第 4.1.2 和 10.12 节）验证响应。


 目录
3.1.3. 令牌端点
为了获取访问令牌、ID 令牌以及可选的刷新令牌，RP（客户端）在使用授权码流程时，向令牌端点发送令牌请求以获取令牌响应，如OAuth 2.0 [RFC6749] 第 3.2 节所述。

与令牌端点的通信必须使用 TLS。有关使用 TLS 的更多信息， 请参阅第 16.17 节。


 目录
3.1.3.1. 令牌请求
客户端通过向令牌端点提交授权许可（以授权码的形式）来发出令牌请求，授权许可的grant_type值为 authorization_code ，具体参见OAuth 2.0 [RFC6749]第 4.1.3 节。如果客户端是机密客户端，则必须使用其client_id上注册的身份验证方法向令牌端点进行身份验证，具体参见第 9 节。

客户端按照OAuth 2.0 [RFC6749] 第 4.1.3节中的说明， 使用 HTTP POST方法和表单序列化 将参数发送到令牌端点。

以下是令牌请求的非规范示例（值内的换行仅用于显示目的）：

  POST /令牌 HTTP/1.1
  主机：server.example.com
  内容类型：application/x-www-form-urlencoded
  授权：基本czZCaGRSa3F0MzpnWDFmQmF0M2JW

  grant_type=授权码&code=SplxlOBeZQQYbYS6WxSbIA
    &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb

 目录
3.1.3.2. 令牌请求验证
授权服务器必须按如下方式验证令牌请求：


如果客户端已颁发客户端凭证或使用其他客户端身份验证方法，则根据第 9 节对客户端进行身份验证。
确保授权码已发给经过身份验证的客户端。
验证授权码是否有效。
如果可能，请验证授权码以前未被使用过。
确保 redirect_uri参数值与 初始授权请求中包含的redirect_uri参数值相同。如果在只有一个已注册的redirect_uri值的情况下不存在该参数值 ，授权服务器可能会返回错误（因为客户端应该已包含该参数），也可能继续执行而不会出现错误（因为 OAuth 2.0 允许在这种情况下省略该参数）。
验证所使用的授权码是否是响应 OpenID Connect 身份验证请求而发出的（以便从令牌端点返回 ID 令牌）。


 目录
3.1.3.3. 成功令牌响应
授权服务器接收并验证客户端发送的有效且已授权的令牌请求后，将返回包含 ID 令牌和访问令牌的成功响应。成功响应中的参数定义在OAuth 2.0 [RFC6749] 第 4.1.4 节中。响应使用application/json 媒体类型。

OAuth 2.0 token_type响应参数值必须是Bearer ，如OAuth 2.0 Bearer 令牌用法[RFC6750]中所述，除非已与客户端协商其他令牌类型。服务器应该支持Bearer令牌类型；使用其他令牌类型不在本规范的讨论范围内。请注意，token_type值不区分大小写。

除了OAuth 2.0指定的响应参数外，响应中还必须包含以下参数：


id_token
与经过身份验证的会话关联的 ID 令牌值。

所有包含令牌、机密或其他敏感信息的令牌响应都必须包含以下 HTTP 响应标头字段和值：


标头名称	标头值
缓存控制	无商店

 HTTP 响应标头和值
以下是一个非规范的成功令牌响应示例。示例中的 ID 令牌签名可以通过附录 A.7 中的密钥进行验证 。

  HTTP/1.1 200 正常
  内容类型：application/json
  缓存控制：无存储

  {
   "access_token": "SlAV32hkKG",
   "token_type": "持有人",
   "refresh_token": "8xLOxBtZp8",
   "expires_in": 3600,
   "id_token": "eyJhbGciOiJSUzI1NiIsImtpZCI6IjFlOWdkazcifQ.ewogImlzc
     yI6ICJodHRwOi8vc2VydmVyLmV4YW1wbGUUY29tIiwKICJzdWIiOiAiMjQ4Mjg5
     NzYxMDAxIiwKICJhdWQiOiAiczZCaGRSa3F0MyIsCiAibm9uY2UiOiAibi0wUzZ
     fV3pBMk1qIiwKICJleHAiOiAxMzExMjgxOTcwLAogImlhdCI6IDEzMTEyODA5Nz
     AKfQ.ggW8hZ1EuVLuxNuuIJKX_V8a_OMXzR0EHR9R6jgdqrOOF4daGU96Sr_P6q
     Jp6IcmD3HP99Obi1PRs-cwh3LO-p146waJ8IhehcwL7F09JdijmBqkvPeB2T9CJ
     NqeGpe-gccMg4vfKjkM8FcGvnzZUN4_KSP0aAp1tOJ1zZwgjxqGByKHiOtX7Tpd
     QyHE5lcMiKPXfEIQILVq0pc_E2DzL7emopWoaoZTF_m0_N0YzFC6g6EJbOEoRoS
     K5hoDalrcvRYLSrQAZZKflyuVCyixEoV9GfNQC3_osjzw2PAithfubEEBLuVVk4
     XUVrWOLrLl0nx7RkKU8NXNHq-rvKMzqg"
  }
根据OAuth 2.0 [RFC6749]中的规定，客户端应该忽略无法识别的响应参数。


 目录
3.1.3.4. 令牌错误响应
如果令牌请求无效或未经授权，授权服务器将构建错误响应。令牌错误响应的参数定义参见OAuth 2.0 [RFC6749] 第 5.2 节。HTTP 响应主体使用application/json 媒体类型，HTTP 响应代码为 400。

以下是非规范的示例令牌错误响应：

  HTTP/1.1 400 错误请求
  内容类型：application/json
  缓存控制：无存储

  {
   “错误”：“无效请求”
  }

 目录
3.1.3.5. 令牌响应验证
客户端必须验证令牌响应如下：

遵循 RFC 6749 中的验证规则，尤其是第 5.1 节和第 10.12 节中的规则。
遵循第 3.1.3.7 节 中的 ID Token 验证规则。
遵循第 3.1.3.8 节 中的访问令牌验证规则。


 目录
3.1.3.6. ID令牌
ID 令牌的内容如第 2 节所述。使用授权码流程时，以下 ID 令牌声明的附加要求适用：


at_hash
可选。访问令牌哈希值。其值是将access_token值 的 ASCII 八位字节哈希值最左半部分进行 base64url 编码 ，其中使用的哈希算法与ID 令牌 JOSE 标头的alg标头参数中使用的哈希算法相同。例如，如果alg为 RS256，则 使用 SHA-256 哈希值对access_token值进行哈希处理，然后取最左 128 位并进行 base64url 编码。at_hash值是区分大小写的字符串。


 目录
3.1.3.7. ID 令牌验证
客户端必须按照以下方式验证令牌响应中的 ID 令牌：


如果 ID 令牌已加密，请使用客户端在注册时指定的密钥和算法对其进行解密，这些密钥和算法是 OP 加密 ID 令牌时使用的。如果在注册时已与 OP 协商加密方式，但 ID 令牌未加密，则 RP 应该拒绝该令牌。
OpenID 提供商的发行者标识符（通常在发现期间获得）必须与 iss（发行者）声明的值完全匹配。
客户端必须验证 aud（受众）声明是否包含其在iss （发行者）声明标识的发行者处注册的 client_id值，该发行者为受众。aud （受众）声明可以包含包含多个元素的数组。如果 ID 令牌未将客户端列为有效受众，或者包含客户端不信任的其他受众，则必须拒绝该 ID 令牌。
如果实现使用扩展（超出本规范的范围）导致azp（授权方）声明存在，则它应该按照这些扩展所指定的方式 验证azp值。
此验证可能包括当存在azp （授权方）声明时，客户端应验证其client_id 是否为声明值。
如果 ID 令牌是通过客户端与令牌端点之间的直接通信接收的（在本流程中如此），则可以使用 TLS 服务器验证来验证颁发者，而不是检查令牌签名。客户端必须根据 JWS [JWS] 使用 JWT alg标头参数中指定的算法验证所有其他 ID 令牌的签名。客户端必须使用颁发者提供的密钥。
alg值应该是RS256的默认值 或客户端在注册期间在id_token_signed_response_alg参数 中发送的算法。
如果 JWT alg标头参数使用基于 MAC 的算法（例如 HS256、HS384或HS512 ） ，则aud （受众）声明中包含的 client_id对应的 client_secret的UTF-8 [RFC3629]八位字节将用作验证签名的密钥。对于基于 MAC 的算法，如果aud为多值， 则行为未指定。
当前时间必须早于exp Claim 所表示的时间 。
iat声明可用于拒绝距离当前时间过远的令牌，从而限制随机数需要存储的时间，以防止攻击。可接受的范围因客户端而异。
如果在身份验证请求中发送了 nonce 值，则必须提供nonce声明，并检查其值是否与身份验证请求中发送的值相同。客户端应该检查nonce值是否存在重放攻击。检测重放攻击的具体方法因客户端而异。
如果请求了acr声明，客户端应该检查所声明的声明值是否合适。acr 声明值的含义和处理 超出了本规范的范围 。
如果请求了auth_time声明，无论是通过针对此声明的特定请求还是使用max_age参数，客户端都应检查auth_time声明值，如果确定自上次最终用户身份验证以来已经过去了太多时间，则请求重新身份验证。


 目录
3.1.3.8. 访问令牌验证
使用授权码流程时，如果 ID 令牌包含at_hash声明，则客户端可以使用它来验证访问令牌，方式与隐式流程相同，如第 3.2.2.9 节中定义，但使用从令牌端点返回的 ID 令牌和访问令牌。


 目录
3.2. 使用隐式流程进行身份验证
本节介绍如何使用隐式流程执行身份验证。使用隐式流程时，所有令牌均从授权端点返回；不使用令牌端点。

隐式流程主要由使用脚本语言在浏览器中实现的客户端使用。访问令牌和 ID 令牌会直接返回给客户端，客户端可能会将其暴露给最终用户以及有权访问最终用户用户代理的应用程序。授权服务器不执行客户端身份验证。


 目录
3.2.1. 隐式流程步骤
隐式流程遵循以下步骤：


客户端准备包含所需请求参数的身份验证请求。
客户端向授权服务器发送请求。
授权服务器对最终用户进行身份验证。
授权服务器获得最终用户的同意/授权。
授权服务器将最终用户连同 ID 令牌以及（如果请求）访问令牌一起发回给客户端。
客户端验证 ID 令牌并检索最终用户的主题标识符。


 目录
3.2.2. 授权端点
使用隐式流程时，授权端点的使用方式与授权码流程相同，如第 3.1.2 节所定义，但本节中指定的差异除外。


 目录
3.2.2.1. 认证请求
身份验证请求按照第 3.1.2.1 节 中的定义进行，但这些身份验证请求参数的使用方式如下：


响应类型
必需。OAuth 2.0 响应类型值，用于确定要使用的授权处理流程，包括从所用端点返回的参数。使用隐式流程时，此值为 id_token token或 id_token 。这两个值的含义均在OAuth 2.0 多响应类型编码实践[OAuth.Responses]中定义 。当值为 id_token时，不会返回访问令牌。
注意：虽然 OAuth 2.0 也为隐式流定义了 令牌响应类型值，但 OpenID Connect 不使用此响应类型，因为不会返回任何 ID 令牌。
重定向uri
必需。响应将被发送到的重定向 URI。此 URI 必须与客户端在 OpenID 提供商处预先注册的重定向 URI 值之一完全匹配，匹配过程按照[RFC3986]第 6.2.1 节（简单字符串比较）中的说明执行。使用此流程时，重定向 URI 不得使用http方案，除非客户端是原生应用；如果是原生应用，则可以使用http方案，并使用 localhost或 IP 环回字符串 127.0.0.1或[::1] 作为主机名。
随机数
必需。用于将客户端会话与 ID 令牌关联起来并缓解重放攻击的字符串值。该值会原封不动地从身份验证请求传递到 ID 令牌。nonce 值必须具有足够的熵， 以防止攻击者猜测值。有关实现说明，请参阅第 15.5.2 节。

以下是使用隐式流程的非规范示例请求，该请求将由用户代理发送到授权服务器，以响应客户端相应的 HTTP 302 重定向响应（值内的换行符仅为了显示目的）：

  获取/授权？
    响应类型=id_token%20token
    &客户端 ID=s6BhdRkqt3
    &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb
    &scope=openid%20profile
    &state=af0ifjsldkj
    &nonce=n-0S6_WzA2Mj HTTP/1.1
  主机：server.example.com

 目录
3.2.2.2. 身份验证请求验证
使用隐式流程时，身份验证请求的验证方式与授权码流程相同，如第 3.1.2.2 节所定义。


 目录
3.2.2.3. 授权服务器验证最终用户
使用隐式流程时，最终用户身份验证的执行方式与授权码流程相同，如第 3.1.2.3 节所定义。


 目录
3.2.2.4. 授权服务器获得最终用户的同意/授权
使用隐式流程时，以与授权码流程相同的方式获得最终用户同意，如第 3.1.2.4 节所定义。


 目录
3.2.2.5. 成功认证响应
使用隐式流程时，身份验证响应的方式与授权码流程相同，如第 3.1.2.5 节所定义，但本节中指定的差异除外。

使用隐式流程时，所有响应参数都将添加到重定向 URI 的片段组件中，如 OAuth 2.0 多响应类型编码实践[OAuth.Responses] 中所述，除非指定了不同的响应模式。

这些参数从授权端点返回：


访问令牌
OAuth 2.0 访问令牌。除非使用的 respond_type值为id_token ，否则将返回此令牌。
令牌类型
OAuth 2.0 令牌类型值。该值必须是Bearer或客户端与授权服务器协商的其他token_type值。实现此配置文件的客户端必须支持OAuth 2.0 Bearer 令牌使用规范 [RFC6750]。此配置文件仅描述 Bearer 令牌的使用。此配置文件的返回情况与 access_token相同。
id_token
必需。ID 令牌。
状态
OAuth 2.0 状态值。如果 授权请求中包含state参数，则此参数为必填项。客户端必须验证该 状态值是否与授权请求中的 state参数值相等。
expires_in
可选。访问令牌自响应生成以来的过期时间（以秒为单位）。

根据OAuth 2.0 [RFC6749] 第 4.2.2 节，使用隐式流程时不会返回 任何代码结果。

以下是使用隐式流程成功响应的非规范示例（仅为显示目的而换行）：

  HTTP/1.1 302 已找到
  位置：https://client.example.org/cb#
    访问令牌=SlAV32hkKG
    &token_type=bearer
    &id_token=eyJ0...NiJ9.eyJ1c...I6IjIifX0.DeWt4Qu...ZXso
    &expires_in=3600
    &state=af0ifjsldkj

 目录
3.2.2.6. 认证错误响应
使用隐式流程时，授权错误响应的方式与授权码流程相同，如第 3.1.2.6 节所定义，但本节中指定的差异除外。

每当返回错误响应参数时，例如当最终用户拒绝授权或最终用户身份验证失败时，授权服务器必须在重定向 URI 的片段组件中返回错误授权响应，如 OAuth 2.0 [RFC6749] 和 OAuth 2.0 多响应类型编码实践[OAuth.Responses] 第 4.2.2.1 节所定义，除非指定了不同的响应模式。


 目录
3.2.2.7. 重定向 URI 片段处理
由于响应参数以重定向 URI 片段值的形式返回，因此客户端需要让用户代理解析片段编码值，并将其传递给客户端的处理逻辑以供使用。有关 URI 片段处理的实现说明， 请参阅第 15.5.3 节。


 目录
3.2.2.8. 身份验证响应验证
使用隐式流程时，客户端必须按如下方式验证响应：

验证响应是否符合 [OAuth.Responses]第 5 节。
遵循 RFC 6749 中的验证规则，尤其是第 4.2.2 和 10.12 节中的规则。
遵循第 3.2.2.11 节 中的 ID 令牌验证规则。
遵循第 3.2.2.9 节 中的访问令牌验证规则，除非使用的respond_type值是 id_token。


 目录
3.2.2.9. 访问令牌验证
要使用 ID 令牌验证从授权端点颁发的访问令牌，客户端应该执行以下操作：


使用JWA [JWA] 中为 ID 令牌的 JOSE 标头中的alg标头参数 指定的哈希算法，对access_token的 ASCII 表示形式的八位字节进行哈希处理。例如，如果alg为 RS256，则使用的哈希算法为 SHA-256。
取哈希值最左边的一半并对其进行 base64url 编码。
ID Token 中的at_hash 值必须与上一步生成的值匹配。


 目录
3.2.2.10. ID令牌
ID 令牌的内容如第 2 节所述。使用隐式流程时，以下 ID 令牌声明的附加要求适用：


随机数
此流程必须 使用nonce声明。
at_hash
访问令牌哈希值。其值是将access_token值 的 ASCII 表示的八位字节哈希值最左半部分进行 base64url 编码 ，其中使用的哈希算法与ID 令牌 JOSE 标头的alg标头参数中使用的哈希算法相同。例如，如果alg为 RS256，则 使用 SHA-256 哈希值对access_token值进行哈希处理，然后取最左 128 位并对其进行 base64url 编码。at_hash值是区分大小写的字符串。
如果从授权端点发出的 ID 令牌具有 access_token值（对于respond_type值 id_token token就是这种情况），则这是必需的；当未发出访问令牌时不得使用它（对于respond_type值 id_token就是这种情况） 。


 目录
3.2.2.11. ID 令牌验证
使用隐式流程时，必须按照第 3.1.3.7 节 中定义的授权码流程相同的方式验证 ID 令牌的内容，但本节中指定的差异除外。


客户端必须使用JOSE Header 的 alg Header 参数中指定的算法， 根据 JWS [JWS] 验证 ID 令牌的签名。
必须检查nonce声明 的值 ，以确保其与身份验证请求中发送的值相同。客户端应该检查nonce值是否存在重放攻击。检测重放攻击的具体方法因客户端而异。


 目录
3.3. 使用混合流程进行身份验证
本节介绍如何使用混合流程进行身份验证。使用混合流程时，一些令牌会从授权端点返回，另一些令牌会从令牌端点返回。混合流程中返回令牌的机制在 OAuth 2.0 多响应类型编码实践[OAuth.Responses] 中指定。


 目录
3.3.1. 混合流程步骤
混合流程遵循以下步骤：


客户端准备包含所需请求参数的身份验证请求。
客户端向授权服务器发送请求。
授权服务器对最终用户进行身份验证。
授权服务器获得最终用户的同意/授权。
授权服务器将最终用户连同授权码一起发送回客户端，并且根据响应类型，发送一个或多个附加参数。
客户端使用令牌端点处的授权码请求响应。
客户端收到响应，响应主体中包含 ID 令牌和访问令牌。
客户端验证 ID 令牌并检索最终用户的主题标识符。


 目录
3.3.2. 授权端点
使用混合流程时，授权端点的使用方式与授权码流程相同，如第 3.1.2 节所定义，但本节中指定的差异除外。


 目录
3.3.2.1. 认证请求
身份验证请求按照第 3.1.2.1 节 中的定义进行，但这些身份验证请求参数的使用方式如下：


响应类型
必需。OAuth 2.0 响应类型值，用于确定要使用的授权处理流程，包括从所用端点返回的参数。使用混合流程时，此值为 code id_token、 code token或 code id_token token 。这些值的含义在OAuth 2.0 多响应类型编码实践[OAuth.Responses] 中定义 。
随机数
如果请求的响应类型为code id_token 或code id_token token，则此属性为必需；如果请求的响应类型为code token ，则此属性为可选。它是一个字符串值，用于将客户端会话与 ID 令牌关联，并缓解重放攻击。该值会原封不动地从身份验证请求传递到 ID 令牌。nonce 值必须具有足够的熵， 以防止攻击者猜测值。有关实现说明，请参阅第 15.5.2 节。

以下是使用混合流程的非规范示例请求，该请求将由用户代理发送到授权服务器，以响应客户端相应的 HTTP 302 重定向响应（值内的换行符仅为了显示目的）：

  获取/授权？
    响应类型=代码%20id_token
    &客户端 ID=s6BhdRkqt3
    &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb
    &scope=openid%20profile%20email
    &nonce=n-0S6_WzA2Mj
    &state=af0ifjsldkj HTTP/1.1
  主机：server.example.com

 目录
3.3.2.2. 身份验证请求验证
使用混合流程时，身份验证请求的验证方式与授权码流程相同，如第 3.1.2.2 节所定义。


 目录
3.3.2.3. 授权服务器验证最终用户
使用混合流程时，最终用户身份验证的执行方式与授权码流程相同，如第 3.1.2.3 节所定义。


 目录
3.3.2.4. 授权服务器获得最终用户的同意/授权
使用混合流程时，以与授权码流程相同的方式获得最终用户同意，如第 3.1.2.4 节所定义。


 目录
3.3.2.5. 成功认证响应
使用混合流程时，身份验证响应的方式与隐式流程相同，如第 3.2.2.5 节所定义，但本节中指定的差异除外。

这些授权端点结果的使用方式如下：


访问令牌
OAuth 2.0 访问令牌。当使用的 respond_type值为code token或code id_token token时，会返回此令牌。（在相同情况下，也会返回 token_type值。）
id_token
ID 令牌。当使用的 respond_type值为code id_token或 code id_token token 时返回此令牌。
代码
授权码。使用混合流程时始终会返回此信息。

以下是使用混合流成功响应的非规范示例（仅为显示目的而换行）：

  HTTP/1.1 302 已找到
  位置：https://client.example.org/cb#
    代码=SplxlOBeZQQYbYS6WxSbIA
    &id_token=eyJ0...NiJ9.eyJ1c...I6IjIifX0.DeWt4Qu...ZXso
    &state=af0ifjsldkj

 目录
3.3.2.6. 认证错误响应
使用混合流程时，授权错误响应的方式与授权码流程相同，如第 3.1.2.6 节所定义，但本节中指定的差异除外。

每当返回错误响应参数时，例如当最终用户拒绝授权或最终用户身份验证失败时，授权服务器必须在重定向 URI 的片段组件中返回错误授权响应，如 OAuth 2.0 [RFC6749] 和 OAuth 2.0 多响应类型编码实践[OAuth.Responses] 第 4.2.2.1 节所定义，除非指定了不同的响应模式。


 目录
3.3.2.7. 重定向 URI 片段处理
使用混合流时，重定向 URI 片段参数处理的要求与隐式流相同，定义见第 3.2.2.7 节。另请参阅第 15.5.3 节，了解有关 URI 片段处理的实现说明。


 目录
3.3.2.8. 身份验证响应验证
使用混合流程时，客户端必须按如下方式验证响应：

验证响应是否符合 [OAuth.Responses]第 5 节。
遵循 RFC 6749 中的验证规则，尤其是第 4.2.2 和 10.12 节中的规则。
当使用的 response_type值为code id_token或 code id_token token时，请遵循第 3.3.2.12 节 中的ID Token验证规则。
当使用的 response_type值为code token或 code id_token token时，请遵循第 3.3.2.9 节 中的访问令牌验证规则。
当使用的 response_type值为code id_token或 code id_token token时，请遵循第3.3.2.10节 中的授权码验证规则。


 目录
3.3.2.9. 访问令牌验证
使用混合流程时，从授权端点返回的访问令牌以与隐式流程相同的方式进行验证，如第 3.2.2.9 节所定义。


 目录
3.3.2.10. 授权码验证
要使用 ID 令牌验证从授权端点发出的授权码，客户端应该执行以下操作：


使用JWA [JWA] 中为 ID 令牌的 JOSE 标头中的alg标头参数 指定的哈希算法，对代码的 ASCII 表示的八位字节进行哈希处理。例如，如果alg为 RS256，则使用的哈希算法为 SHA-256。
取哈希值最左边的一半并对其进行 base64url 编码。
如果 ID 令牌中存在 c_hash ，则 ID 令牌中c_hash的值必须与上一步生成的值匹配。


 目录
3.3.2.11. ID令牌
ID 令牌的内容如第 2 节所述。使用混合流程时，以下 ID 令牌声明的附加要求适用于从授权端点返回的 ID 令牌：


随机数
如果身份验证请求中存在nonce参数，则授权服务器必须在 ID 令牌中 包含nonce声明。
at_hash
访问令牌哈希值。其值是将access_token值 的 ASCII 表示的八位字节哈希值最左半部分进行 base64url 编码 ，其中使用的哈希算法与ID 令牌 JOSE 标头的alg标头参数中使用的哈希算法相同。例如，如果alg为 RS256，则 使用 SHA-256 哈希值对access_token值进行哈希处理，然后取最左 128 位并对其进行 base64url 编码。at_hash值是区分大小写的字符串。
如果 ID 令牌是从授权端点发出的，并且带有 access_token值（对于respond_type值 代码 id_token token就是这种情况） ，则这是必需的；否则，它的包含是可选的。
c_hash
代码哈希值。其值是将代码值 ASCII 表示的八位字节哈希值最左半部分进行 base64url 编码 ，其中使用的哈希算法与ID 令牌 JOSE 标头的alg标头参数中使用的哈希算法相同。例如，如果alg为 HS512，则 使用 SHA-512 对代码值进行哈希处理，然后取最左 256 位并对其进行 base64url 编码。c_hash值是区分大小写的字符串。
如果 ID 令牌是从授权端点使用 代码发出的（对于respond_type值 代码 id_token和 代码 id_token token就是这种情况），则这是必需的；否则，它的包含是可选的。


 目录
3.3.2.12. ID 令牌验证
使用混合流程时，授权端点返回的 ID 令牌的内容必须按照与隐式流程相同的方式进行验证，如第 3.2.2.11 节所定义。


 目录
3.3.3. 令牌端点
使用混合流程时，令牌端点的使用方式与授权码流程相同，如第 3.1.3 节所定义，但本节中指定的差异除外。


 目录
3.3.3.1. 令牌请求
使用混合流程时，令牌请求的方式与授权码流程相同，如第 3.1.3.1 节所定义。


 目录
3.3.3.2. 令牌请求验证
使用混合流程时，令牌请求的验证方式与授权码流程相同，如第 3.1.3.2 节所定义。


 目录
3.3.3.3. 成功令牌响应
使用混合流程时，令牌响应的方式与授权码流程相同，如第 3.1.3.3 节所定义。


 目录
3.3.3.4. 令牌错误响应
使用混合流程时，令牌错误响应的方式与授权码流程相同，如第 3.1.3.4 节所定义。


 目录
3.3.3.5. 令牌响应验证
使用混合流程时，令牌响应的验证方式与授权码流程相同，如第 3.1.3.5 节所定义。


 目录
3.3.3.6. ID令牌
使用混合流程时，从令牌端点返回的 ID 令牌的内容与从授权端点返回的 ID 令牌的内容相同，如第 3.3.2.11 节所定义，但本节中指定的差异除外。

如果从授权端点和令牌端点都返回了 ID 令牌，例如， response_type值 code id_token和 code id_token token 的情况，则两个 ID 令牌中的iss和sub 声明值必须相同。两者中存在的有关身份验证事件的所有声明都应该同时存在于两者中。如果任一 ID 令牌包含有关最终用户的声明，则两者中都存在的任何声明都应该具有相同的值。请注意，出于隐私原因等原因，OP 可以选择从授权端点返回较少的最终用户声明。即使从授权端点返回的 ID 令牌中存在at_hash 和c_hash声明，也可以从令牌端点返回的 ID 令牌中省略这些声明，因为从令牌端点返回的 ID 令牌和访问令牌值已经通过令牌端点执行的 TLS 加密以加密方式绑定在一起。


 目录
3.3.3.7. ID 令牌验证
使用混合流程时，从令牌端点返回的 ID 令牌的内容必须按照与授权码流程相同的方式进行验证，如第 3.1.3.7 节所定义。


 目录
3.3.3.8. 访问令牌
如果授权端点和令牌端点都返回了访问令牌（例如，response_type 的值为 code token和 code id_token token ），则它们的值可能相同，也可能不同。需要注意的是，由于两个端点的安全特性不同，以及它们授予的资源访问权限和生命周期也可能不同，因此返回的访问令牌也可能不同。


 目录
3.3.3.9. 访问令牌验证
使用混合流程时，从令牌端点返回的访问令牌的验证方式与授权码流程相同，如第 3.1.3.8 节所定义。


 目录
4. 从第三方发起登录
在某些情况下，登录流程是由 OpenID 提供商或其他方（而非依赖方）发起的。在这种情况下，发起方会重定向到 RP 的登录发起端点，请求 RP 向指定的 OP 发送身份验证请求。请注意，此登录发起端点可以是 RP 上的不同页面，而不是 RP 的默认登录页面。支持 OpenID Connect 动态客户端注册 1.0 [OpenID.Registration] 的 RP 使用initiate_login_uri注册参数注册此端点值 。

发起登录请求的一方通过重定向到 RP 的登录发起端点来实现此目的，并传递以下参数：


国际空间站
必填项。RP 向其发送身份验证请求的 OP 的颁发者标识符。其值必须是使用https方案的 URL。
登录提示
可选。向授权服务器提示待认证的最终用户。此字符串值参数的含义由原始用户 (OP) 自行决定。在常见用例中，该值包含 RP 在向原始用户 (OP) 请求身份验证之前收集的电子邮件地址、电话号码或用户名。例如，RP 可以在向最终用户询问其电子邮件地址（或其他标识符）后使用此提示，并将该标识符作为提示传递给 OpenID 提供商。建议提示值与发现过程中提供的值一致。其他用途可能包括使用ID 令牌中的sub声明作为提示值，或使用与所请求身份验证相关的其他类型的信息。
目标链接 uri
可选。RP 身份验证后被请求重定向到的 URL。RP 必须验证target_link_uri 的值， 以防止被用作指向外部网站的开放重定向器。

参数既可以使用 HTTP GET方法作为查询参数传递，也可以作为在用户代理中自动提交的 HTML 表单值传递，从而通过 HTTP POST方法传输。

如果扩展定义了其他参数，则可以发送。任何无法理解的参数都必须被客户端忽略。

客户端应采用框架破坏 (Frame Busting) 和其他技术，以防止最终用户在不知情的情况下通过点击劫持 (Clickjacking) 等攻击被第三方网站登录。更多详情， 请参阅[RFC6819]第 4.4.1.9 节。


 目录
5. 索赔
本节指定了客户端如何获取有关最终​​用户和身份验证事件的声明。它还定义了一组标准的基本配置文件声明。可以使用特定的范围值来请求预定义的声明集，也可以使用 claims请求参数来请求单个声明。这些声明可以直接来自 OpenID 提供者，也可以来自分布式来源。


 目录
5.1. 标准声明
本规范定义了一组标准声明。您可以请求在 UserInfo 响应中返回这些声明（参见第 5.3.2 节）或 ID 令牌中返回这些声明（参见第 2 节）。


成员	类型	描述
潜艇	细绳	主题——发行方最终用户的标识符。
姓名	细绳	最终用户的全名以可显示的形式显示，包括所有姓名部分，可能包括称谓和后缀，并根据最终用户的语言环境和偏好排序。
给定的名称	细绳	最终用户的名字。请注意，在某些文化中，人们可以拥有多个名字；所有名字都可以存在，名字之间用空格分隔。
姓	细绳	最终用户的姓氏。请注意，在某些文化中，人们可以有多个姓氏，也可以没有姓氏；所有姓氏都可以存在，但各个姓氏之间用空格分隔。
中间名字	细绳	最终用户的中间名。请注意，在某些文化中，人们可以有多个中间名；所有中间名均可使用，但各个名字之间以空格分隔。另请注意，在某些文化中，不使用中间名。
昵称	细绳	最终用户的临时名称，可能与 given_name相同，也可能不同。例如，昵称值Mike 可能与given_name 值Michael一起返回。
首选用户名	细绳	最终用户希望在 RP 中被引用的简写名称，例如 janedoe或j.doe。此值可以是任何有效的 JSON 字符串，包含特殊字符，例如@、 /或空格。RP 不得依赖此值的唯一性，如第 5.7 节所述。
轮廓	细绳	最终用户个人资料页面的 URL。该网页的内容应与最终用户相关。
图片	细绳	最终用户个人资料图片的 URL。此 URL 必须指向一个图片文件（例如，PNG、JPEG 或 GIF 图片文件），而不是指向包含图片的网页。请注意，此 URL 应明确指向适合在描述最终用户时显示的最终用户个人资料照片，而不是最终用户拍摄的任意照片。
网站	细绳	最终用户网页或博客的 URL。该网页应包含最终用户或其所属组织发布的信息。
电子邮件	细绳	最终用户的首选电子邮件地址。其值必须符合RFC 5322 [RFC5322] addr-spec 语法。RP 不得依赖此值的唯一性，如第 5.7 节所述。
email_verified	布尔值	如果最终用户的电子邮件地址已验证，则为 True；否则为 false。当此声明值为true时，表示原始用户已采取积极措施，确保在执行验证时该电子邮件地址由最终用户控制。电子邮件地址的验证方式因具体情况而异，并取决于双方所依据的信任框架或合同协议。
性别	细绳	最终用户的性别。本规范定义的值为女性和 男性。当定义的值均不适用时，可以使用其他值。
出生日期	细绳	最终用户的生日，采用 ISO 8601-1 [ISO8601‑1] YYYY-MM-DD 格式表示。年份可以为0000，表示省略。如果仅表示年份，则允许使用YYYY格式。请注意，根据底层平台的日期相关功能，仅提供年份可能会导致月份和日期有所不同，因此实现者需要将此因素考虑在内，以便正确处理日期。
区域信息	细绳	来自 IANA 时区数据库[IANA.time‑zones]的字符串 ，表示最终用户的时区。例如，Europe/Paris或 America/Los_Angeles。
区域设置	细绳	最终用户的区域设置，以 BCP47 [RFC5646] 语言标签表示。通常，它由小写的ISO 639 Alpha-2 [ISO639] 语言代码和大写的ISO 3166-1 Alpha-2 [ISO3166-1] 国家/地区代码组成，中间用短划线分隔。例如， en-US或fr-CA。出于兼容性考虑，某些实现使用下划线而不是短划线作为分隔符，例如， en_US；依赖方也可以选择接受此区域设置语法。
电话号码	细绳	最终用户的首选电话号码。建议使用E.164 [E.164] 作为此声明的格式，例如+1 (425) 555-1212 或+56 (2) 687 2400 。如果电话号码包含分机号，建议使用RFC 3966 [RFC3966] 分机号语法表示分机号 ，例如+1 (604) 555-1234;ext=5678。
电话号码已验证	布尔值	如果最终用户的电话号码已验证，则为 True；否则为 false。当此声明值为true时，表示原始用户已采取积极措施，确保在执行验证时，此电话号码由最终用户控制。电话号码验证方式因具体情况而异，取决于双方所依据的信任框架或合同协议。当此声明值为 true 时，phone_number 声明必须采用 E.164 格式，且任何扩展必须采用 RFC 3966 格式。
地址	JSON 对象	最终用户的首选邮政地址。address成员的值是一个 JSON [RFC8259]结构，包含第 5.1.1 节中定义的部分或全部成员。
更新时间	数字	最终用户信息的最后更新时间。其值是一个 JSON 数字，表示从 1970-01-01T00:00:00Z 到该日期/时间的秒数（以 UTC 时间计算）。

 表 1：注册会员定义

 目录
5.1.1. 地址声明
地址声明代表实际邮寄地址。具体实现可能仅返回地址字段的子集，具体取决于可用信息和最终用户的隐私偏好。例如，可能只返回国家和地区信息，而不返回更细粒度的地址信息。

实现可以仅返回格式化子字段中单个字符串形式的完整地址，也可以仅返回使用其他子字段的各个组成字段，或者可以同时返回两者。如果同时返回两种情况，则它们应该表示相同的地址，格式化地址指示各组成字段的组合方式。

下面定义的所有地址值均表示为 JSON 字符串。


格式化
完整的邮寄地址，已格式化，可用于显示或邮寄标签。此字段可以包含多行，每行之间以换行符分隔。换行符可以表示为回车符/换行符对（“\r\n”）或单个换行符（“\n”）。
街道地址
完整的街道地址组成部分，可能包含门牌号、街道名称、邮政信箱以及多行扩展街道地址信息。此字段可能包含多行，每行之间以换行符分隔。换行符可以表示为回车符/换行符对（“\r\n”）或单个换行符（“\n”）。
地方性
城市或地区组成部分。
地区
州、省、县或地区的组成部分。
邮政编码
邮政编码或邮政编码组成部分。
国家
国家名称组成部分。


 目录
5.1.2. 附加声明
虽然本规范仅定义了一小部分声明作为标准声明，但其他声明可以与标准声明结合使用。使用此类声明时，建议使用防冲突名称作为声明名称，如 JSON Web Token (JWT) [JWT] 规范中所述。或者，当命名冲突不太可能发生时，可以安全地使用私有声明名称，如 JWT 规范中所述。或者，如果特定的附加声明具有广泛且普遍的适用性，则可以根据 JWT 规范将其注册到已注册声明名称中。


 目录
5.2. 声明语言和文字
人类可读的声明值和引用人类可读值的声明值可以用多种语言和文字表示。为了指定语言和文字，BCP47 [RFC5646] 语言标签会添加到成员名称中，并以#字符分隔。例如， family_name#ja-Kana-JP表示日语片假名的家族名称，该标签通常用于索引和表示以family_name#ja-Hani-JP表示的同名汉字的语音。再例如，website和 website#de声明值可能会同时返回，分别引用未指定语言的网站和德语网站。

由于声明名称区分大小写，强烈建议声明名称中使用的语言标签值应使用其在 IANA“语言子标签注册表” [IANA.Language]中注册的大小写字符拼写。具体而言，通常情况下，语言名称使用小写字符拼写，地区名称使用大写字符拼写，文字使用大小写混合字符拼写。但是，由于 BCP47 语言标签值不区分大小写，因此实现应该以不区分大小写的方式解释提供的语言标签值。

根据 BCP47 中的建议，声明的语言标签值应尽可能具体。例如，在许多情况下，使用fr可能就足够了，而不是fr-CA或 fr-FR。在可能的情况下，原始用户 (OP) 应尝试将请求的声明语言环境与其拥有的声明进行匹配。例如，如果客户端请求一个带有de（德语）语言标签的声明，而原始用户 (OP) 的值带有de-CH（瑞士德语）标签，且没有通用的德语值，则原始用户 (OP) 应该将瑞士德语值返回给客户端。（这是为了尽可能地将语言标签匹配的复杂性转移给原始用户 (OP)，以简化客户端。）

OpenID Connect 定义了以下授权请求参数，以便指定返回声明所使用的首选语言和脚本：

claims_locales
可选。返回声明中最终用户偏好的语言和文字，以空格分隔的BCP47 [RFC5646] 语言标签值 列表形式呈现 ，并按偏好排序。如果 OpenID 提供商不支持部分或全部请求的区域设置，则不应导致错误。

当原始开发者 (OP) 通过claims_locales参数或其他方式 确定 最终用户和客户端仅请求一种语言和文字的声明时，建议原始开发者在使用该语言和文字时返回不带语言标签的声明。此外，建议客户端的编写方式使其能够处理和使用带有语言标签的声明。


 目录
5.3. 用户信息端点
UserInfo 端点是受 OAuth 2.0 保护的资源，用于返回已通过身份验证的最终用户的声明。为了获取请求的最终用户声明，客户端需要使用通过 OpenID Connect 身份验证获得的访问令牌向 UserInfo 端点发出请求。这些声明通常以 JSON 对象表示，该对象包含声明的名称和值对的集合。

与 UserInfo 端点的通信必须使用 TLS。有关使用 TLS 的更多信息， 请参阅第 16.17 节。

UserInfo 端点必须支持使用RFC 7231 [RFC7231]中定义的HTTP GET和 HTTP POST方法。

UserInfo 端点必须接受访问令牌作为 OAuth 2.0 承载令牌使用[RFC6750]。

UserInfo 端点应该支持使用 跨域资源共享 (CORS) [CORS] 和/或其他适当方法，以允许 JavaScript 客户端和其他基于浏览器的客户端访问它。


 目录
5.3.1. 用户信息请求
客户端使用 HTTP GET或 HTTP POST 发送 UserInfo 请求。根据OAuth 2.0 Bearer Token 使用规范[RFC6750] 第 2 节的规定，从 OpenID Connect 身份验证请求中获取的访问令牌必须以 Bearer Token 的形式发送。

建议请求使用 HTTP GET方法，并使用授权标头字段发送访问令牌 。

以下是 UserInfo 请求的非规范示例：

  获取/用户信息 HTTP/1.1
  主机：server.example.com
  授权： Bearer SlAV32hkKG

 目录
5.3.2. 成功的 UserInfo 响应
除非在客户端注册期间请求了签名或加密的响应，否则 UserInfo 声明必须作为 JSON 对象的成员返回。第 5.1 节中定义的声明以及未在此处指定的其他声明均可返回。

出于隐私原因，OpenID 提供商可以选择不返回某些请求的声明值。不返回请求的声明并不构成错误。

如果未返回声明，则应从表示声明的 JSON 对象中省略该声明名称；它不应以空值或空字符串值出现。

子（主题）声明必须始终在 UserInfo 响应中返回。

注意：由于存在令牌替换攻击的可能性（参见第 16.11 节），UserInfo 响应无法保证与ID 令牌的sub （subject）元素所标识的最终用户一致。必须验证 UserInfo 响应中的sub声明与 ID 令牌中的sub声明完全匹配 ；如果不匹配，则不得使用 UserInfo 响应的值。

收到 UserInfo 请求后，UserInfo 端点必须 在 HTTP 响应正文中 返回 UserInfo 响应的 JSON 序列化版本，具体格式请参见第 13.3 节，除非在注册[OpenID.Registration]过程中指定了其他格式。UserInfo 端点必须返回一个 Content-Type 标头，以指示返回的格式。如果响应正文是文本 JSON 对象，则 HTTP 响应的 Content-Type 必须为application/json；响应正文应使用 UTF-8 编码。

如果 UserInfo 响应已签名和/或加密，则声明将以 JWT 形式返回，且内容类型必须为application/jwt。响应可以加密，但无需签名。如果同时请求签名和加密，则响应必须先签名，然后再加密，最终返回结果为嵌套 JWT，定义见[JWT]。

如果已签名，UserInfo 响应必须包含声明 iss（发行者）和aud（受众）作为成员。iss值必须是原始用户 (OP) 的发行者标识符 URL。aud 值必须是或包含原始用户 (RP) 的客户端 ID 值。

以下是 UserInfo Response 的非规范示例：

  HTTP/1.1 200 正常
  内容类型：application/json

  {
   "sub": "248289761001",
   “姓名”：“Jane Doe”，
   "given_name": "Jane",
   "family_name": "Doe",
   "preferred_username": "j.doe",
   “电子邮件”：“janedoe@example.com”，
   “图片”：“http://example.com/janedoe/me.jpg”
  }

 目录
5.3.3. UserInfo 错误响应
当发生错误情况时，UserInfo 端点将返回 OAuth 2.0 Bearer Token 使用[RFC6750] 第 3 节中定义的错误响应。（与 RFC 6750 无关的 HTTP 错误将使用相应的 HTTP 状态代码返回给用户代理。）

以下是 UserInfo 错误响应的非规范示例：

  HTTP/1.1 401 未授权
  WWW-身份验证：持有者错误=“invalid_token”，
    error_description="访问令牌已过期"

 目录
5.3.4. UserInfo 响应验证
客户端必须按如下方式验证 UserInfo 响应：


按照RFC 6125 [RFC6125] ，通过 TLS 服务器证书检查验证响应的 OP 是否为预期的 OP 。
如果客户端在注册期间提供了 userinfo_encrypted_response_alg 参数，则使用注册期间指定的密钥解密 UserInfo 响应。
如果响应已签名，客户端应该根据JWS [JWS] 验证签名。


 目录
5.4. 使用范围值请求声明
OpenID Connect 客户端使用OAuth 2.0 [RFC6749]第 3.3 节中定义的范围值来指定请求访问令牌的访问权限。与访问令牌关联的范围决定了当使用访问令牌访问受 OAuth 2.0 保护的端点时可用的资源。受保护资源端点可以根据范围值以及请求所提供访问令牌时使用的其他参数执行不同的操作并返回不同的信息。

对于 OpenID Connect，可以使用范围来请求将特定信息集作为声明值提供。

授权服务器将以下范围请求的声明视为自愿声明。

OpenID Connect 定义了以下用于请求声明的 范围值：


轮廓
可选。此范围值请求访问最终用户的默认个人资料声明，包括： name、 family_name、 given_name、 middle_name、 nickname、 preferred_username、 profile、 picture、 website、 gender、 birthdate、 zoneinfo、 locale和 updated_at。
电子邮件
可选。此范围值请求访问电子邮件和 email_verified声明。
地址
可选。此范围值请求访问地址声明。
电话
可选。此范围值请求访问phone_number和 phone_number_verified声明。

可以通过创建空格分隔、区分大小写的 ASCII 范围值列表来使用多个范围值。

如第 5.3.2 节所述，当使用导致颁发访问令牌的respond_type值时， profile、 email、 address和 phone范围值 所请求的声明 将从 UserInfo 端点返回。但是，如果没有颁发访问令牌（ response_type 值为id_token的情况），则生成的声明将返回到 ID 令牌中。

在某些情况下，最终用户可以选择让 OpenID 提供商拒绝提供 RP 请求的部分或全部信息。为了最大限度地减少最终用户被要求披露的信息量，RP 可以选择仅请求 UserInfo 端点提供的部分信息。


以下是未编码 范围请求的非规范示例：

  scope=openid 个人资料 电子邮件 电话

 目录
5.5. 使用“claims”请求参数请求索赔
OpenID Connect 定义了以下授权请求参数，以允许请求单独的声明并指定适用于所请求声明的参数：

索赔
可选。此参数用于请求返回特定的声明。其值是一个 JSON 对象，列出了所请求的声明。

身份验证请求的 claims参数要求从 UserInfo 端点和/或 ID 令牌中返回特定的声明。该参数以 JSON 对象的形式表示，其中包含从这些位置请求的声明列表。还可以指定所请求声明的属性。

对claims参数 的支持是可选的。如果原始用户 (OP) 不支持此参数，而参考用户 (RP) 使用了此参数，原始用户 (OP) 应使用其认为合适的启发式方法，向参考用户 (RP) 返回一组其认为对参考用户 (RP) 和最终用户有用的声明。claims_parameter_supported发现 结果指示原始用户 (OP) 是否支持此参数。

claims 参数值在 OAuth 2.0 请求中以 UTF-8 编码的 JSON 格式表示（作为 OAuth 参数传递时，最终会进行 form-urlencoded 编码）。当用于请求对象值时，根据第 6.1 节的规定，该 JSON 格式将用作claims成员的值 。

Claims 请求 JSON 对象的顶级成员是：

用户信息
可选。请求从 UserInfo 端点返回列出的单个声明。如果存在，则请求将列出的声明添加到使用范围值 请求的任何声明中 。如果不存在，则从 UserInfo 端点请求的声明仅限于使用 范围值请求的声明。
当使用userinfo成员时，请求还必须使用一个respond_type 值，该值会导致向客户端发出访问令牌以供在 UserInfo 端点使用。
id_token
可选。请求在 ID 令牌中返回列出的单个声明。如果存在，则请求将列出的声明添加到 ID 令牌中的默认声明中。如果不存在，则根据第 2 节中的 ID 令牌定义以及第 3.1.3.6节、 3.2.2.10 节、 3.3.2.11 节和3.3.3.6 节中附加的每流 ID 令牌要求， 请求默认的 ID 令牌声明。

其他成员可能存在。任何无法理解的成员都必须被忽略。


索赔请求示例如下：

  {
   "用户信息":
    {
     "given_name": {"essential": true},
     “昵称”：空，
     “电子邮件”：{“基本”：true}，
     “email_verified”：{“essential”：true}，
     “图片”：空，
     “http://example.info/claims/groups”：空
    }，
   “id_token”：
    {
     “auth_time”：{“essential”：true}，
     “acr”：{“值”：[“urn：mace：incommon：iap：silver”]}
    }
  }
请注意，所请求的声明不属于 第 5.1 节中定义的标准集合，例如 http://example.info/claims/groups声明。使用claims参数是请求特定声明组合的唯一方法，这些组合无法使用范围值指定。
 目录
5.5.1. 个人索赔请求
The userinfo and id_token members of the claims request both are JSON objects with the names of the individual Claims being requested as the member names. The member values MUST be one of the following:

null
Indicates that this Claim is being requested in the default manner. In particular, this is a Voluntary Claim. For instance, the Claim request:
  "given_name": null
requests the given_name Claim in the default manner.
JSON Object
Used to provide additional information about the Claim being requested. This specification defines the following members:
essential
OPTIONAL. Indicates whether the Claim being requested is an Essential Claim. If the value is true, this indicates that the Claim is an Essential Claim. For instance, the Claim request:
  "auth_time": {"essential": true}
can be used to specify that it is Essential to return an auth_time Claim Value.
If the value is false, it indicates that it is a Voluntary Claim. The default is false.
By requesting Claims as Essential Claims, the RP indicates to the End-User that releasing these Claims will ensure a smooth authorization for the specific task requested by the End-User. Note that even if the Claims are not available because the End-User did not authorize their release or they are not present, the Authorization Server MUST NOT generate an error when Claims are not returned, whether they are Essential or Voluntary, unless otherwise specified in the description of the specific claim.
value
OPTIONAL. Requests that the Claim be returned with a particular value. For instance, the Claim request:
  "sub": {"value": "248289761001"}
can be used to specify that the request apply to the End-User with Subject Identifier 248289761001.
The value of the value member MUST be a valid value for the Claim being requested. Definitions of individual Claims can include requirements on how and whether the value qualifier is to be used when requesting that Claim. An equality comparison is used to determine whether the requested Claim value matches.
When the Claim value does not match the requested value, the Claim is not included in the response. If the Claim was sub, a mismatch MUST cause the authentication to fail, as described in Section 3.1.2.2.
values
OPTIONAL. Requests that the Claim be returned with one of a set of values, with the values appearing in order of preference. This is processed equivalently to a value request, except that a choice of acceptable Claim values is provided.
For instance, the Claim request:
  "acr": {"essential": true,
          "values": ["urn:mace:incommon:iap:silver",
                     "urn:mace:incommon:iap:bronze"]}
specifies that it is Essential that the acr Claim be returned with either the value urn:mace:incommon:iap:silver or urn:mace:incommon:iap:bronze.
The values in the values member array MUST be valid values for the Claim being requested. Definitions of individual Claims can include requirements on how and whether the values qualifier is to be used when requesting that Claim. An equality comparison is used to determine whether the requested Claim values match.
When the Claim value does not match any of the requested values, the Claim is not included in the response.
Other members MAY be defined to provide additional information about the requested Claims. Any members used that are not understood MUST be ignored.

Note that when the claims request parameter is supported, the scope values that request Claims, as defined in Section 5.4, are effectively shorthand methods for requesting sets of individual Claims. For example, using the scope value openid email and a response_type that returns an Access Token is equivalent to using the scope value openid and the following request for individual Claims.

Equivalent of using the email scope value:

  {
   "userinfo":
    {
     "email": null,
     "email_verified": null
    }
  }

 TOC
5.5.1.1.  Requesting the "acr" Claim
If the acr Claim is requested as an Essential Claim for the ID Token with a value or values parameter requesting specific Authentication Context Class Reference values and the implementation supports the claims parameter, the Authorization Server MUST return an acr Claim Value that matches one of the requested values. The Authorization Server MAY ask the End-User to re-authenticate with additional factors to meet this requirement. If this is an Essential Claim and the requirement cannot be met, then the Authorization Server MUST treat that outcome as a failed authentication attempt.

Note that the RP MAY request the acr Claim as a Voluntary Claim by using the acr_values request parameter or by not including "essential": true in an individual acr Claim request. If the Claim is not Essential and a requested value cannot be provided, the Authorization Server SHOULD return the session's current acr as the value of the acr Claim. If the Claim is not Essential, the Authorization Server is not required to provide this Claim in its response.

If the client requests the acr Claim using both the acr_values request parameter and an individual acr Claim request for the ID Token listing specific requested values, the resulting behavior is unspecified.


 TOC
5.5.2.  Languages and Scripts for Individual Claims
As described in Section 5.2, human-readable Claim Values and Claim Values that reference human-readable values MAY be represented in multiple languages and scripts. Within a request for individual Claims, requested languages and scripts for particular Claims MAY be requested by including Claim Names that contain #-separated BCP47 [RFC5646] language tags in the Claims request, using the Claim Name syntax specified in Section 5.2. For example, a Family Name in Katakana in Japanese can be requested using the Claim Name family_name#ja-Kana-JP and a Kanji representation of the Family Name in Japanese can be requested using the Claim Name family_name#ja-Hani-JP. A German-language Web site can be requested with the Claim Name website#de.

If an OP receives a request for human-readable Claims in a language and script that it does not have, any versions of those Claims returned that do not use the requested language and script SHOULD use a language tag in the Claim Name.


 TOC
5.6.  Claim Types
Three representations of Claim Values are defined by this specification:


Normal Claims
Claims that are directly asserted by the OpenID Provider.
Aggregated Claims
Claims that are asserted by a Claims Provider other than the OpenID Provider but are returned by OpenID Provider.
Distributed Claims
Claims that are asserted by a Claims Provider other than the OpenID Provider but are returned as references by the OpenID Provider.

Normal Claims MUST be supported. Support for Aggregated Claims and Distributed Claims is OPTIONAL.


 TOC
5.6.1.  Normal Claims
Normal Claims are represented as members in a JSON object. The Claim Name is the member name and the Claim Value is the member value.

The following is a non-normative response containing Normal Claims:

  {
   "sub": "248289761001",
   "name": "Jane Doe",
   "given_name": "Jane",
   "family_name": "Doe",
   "email": "janedoe@example.com",
   "picture": "http://example.com/janedoe/me.jpg"
  }

 TOC
5.6.2.  Aggregated and Distributed Claims
Aggregated and distributed Claims are represented by using special _claim_names and _claim_sources members of the JSON object containing the Claims.


_claim_names
JSON object whose member names are the Claim Names for the Aggregated and Distributed Claims. The member values are references to the member names in the _claim_sources member from which the actual Claim Values can be retrieved. The OP MAY omit some Claims available from referenced Claims Providers from the set of Claim Names.
_claim_sources
JSON object whose member names are referenced by the member values of the _claim_names member. The member values contain sets of Aggregated Claims or reference locations for Distributed Claims. The member values can have one of the following formats depending on whether it is providing Aggregated or Distributed Claims:
Aggregated Claims
JSON object that MUST contain the JWT member whose value is a JWT [JWT] that MUST contain all the Claims in the _claim_names object that references the corresponding _claim_sources member. Other members MAY be present. Any members used that are not understood MUST be ignored.
JWT
REQUIRED. JWT containing Claim Values.
The JWT SHOULD NOT contain a sub (subject) Claim unless its value is an identifier for the End-User at the Claims Provider (and not for the OpenID Provider or another party); this typically means that a sub Claim SHOULD NOT be provided.
Distributed Claims
JSON object that contains the following members and values:
endpoint
REQUIRED. OAuth 2.0 resource endpoint from which the associated Claim can be retrieved. The endpoint URL MUST return the Claim as a JWT.
access_token
OPTIONAL. Access Token enabling retrieval of the Claims from the endpoint URL by using the OAuth 2.0 Bearer Token Usage [RFC6750] protocol. Claims SHOULD be requested using the Authorization Request header field and Claims Providers MUST support this method. If the Access Token is not available, RPs MAY need to retrieve the Access Token out of band or use an Access Token that was pre-negotiated between the Claims Provider and RP, or the Claims Provider MAY reauthenticate the End-User and/or reauthorize the RP.
Since it is not an error condition to not return a requested Claim, RPs MUST be prepared to handle the condition that some Claims listed in _claim_sources are not returned from the Claims Provider. They SHOULD treat this the same as when any other requested Claim is not returned.
A sub (subject) Claim SHOULD NOT be returned from the Claims Provider unless its value is an identifier for the End-User at the Claims Provider (and not for the OpenID Provider or another party); this typically means that a sub Claim SHOULD NOT be provided.

An iss (issuer) Claim SHOULD be included in any JWT issued by a Claims Provider so that the Claims Provider's keys can be retrieved for signature validation of the JWT. The value of the Claim is the Claims Provider's Issuer Identifier URL.

In general, it is up to the OP when it is appropriate to use Aggregated Claims and Distributed Claims. In some cases, information about when to use what Claim Types might be negotiated out of band between RPs and OPs.


 TOC
5.6.2.1.  Example of Aggregated Claims
In this non-normative example, Claims from Claims Provider A are combined with other Claims held by the OpenID provider, with the Claims from Claims Provider A being returned as Aggregated Claims.


In this example, these Claims about Jane Doe have been issued by Claims Provider A. (The example also includes the Claims Provider's Issuer Identifier URL.)

  {
   "iss": "https://a.example.com",
   "address": {
     "street_address": "1234 Hollywood Blvd.",
     "locality": "Los Angeles",
     "region": "CA",
     "postal_code": "90210",
     "country": "United States of America"},
   "phone_number": "+1 (310) 123-4567"
  }
Claims Provider A signs the JSON Claims, representing them in a signed JWT: jwt_header.jwt_part2.jwt_part3. It is this JWT that is used by the OpenID Provider.


In this example, this JWT containing Jane Doe's Aggregated Claims from Claims Provider A is combined with other Normal Claims, and returned as the following set of Claims:

  {
   "sub": "248289761001",
   "name": "Jane Doe",
   "given_name": "Jane",
   "family_name": "Doe",
   "birthdate": "0000-03-22",
   "eye_color": "blue",
   "email": "janedoe@example.com",
   "_claim_names": {
     "address": "src1",
     "phone_number": "src1"
   },
   "_claim_sources": {
     "src1": {"JWT": "jwt_header.jwt_part2.jwt_part3"}
   }
  }

 TOC
5.6.2.2.  Example of Distributed Claims
In this non-normative example, the OpenID Provider combines Normal Claims that it holds with references to Claims held by two different Claims Providers, B and C, incorporating references to some of the Claims held by B and C as Distributed Claims.


In this example, these Claims about Jane Doe are held by Claims Provider B (Jane Doe's bank). (The example also includes the Claims Provider's Issuer Identifier URL.)

  {
   "iss": "https://bank.example.com",
   "shipping_address": {
     "street_address": "1234 Hollywood Blvd.",
     "locality": "Los Angeles",
     "region": "CA",
     "postal_code": "90210",
     "country": "United States of America"},
   "payment_info": "Some_Card 1234 5678 9012 3456",
   "phone_number": "+1 (310) 123-4567"
  }

Also in this example, this Claim about Jane Doe is held by Claims Provider C (a credit agency). (The example also includes the Claims Provider's Issuer Identifier URL.)

  {
   "iss": "https://creditagency.example.com",
   "credit_score": 650
  }

The OpenID Provider returns Jane Doe's Claims along with references to the Distributed Claims from Claims Provider B and Claims Provider C by sending the Access Tokens and URLs of locations from which the Distributed Claims can be retrieved:

  {
   "sub": "248289761001",
   "name": "Jane Doe",
   "given_name": "Jane",
   "family_name": "Doe",
   "email": "janedoe@example.com",
   "birthdate": "0000-03-22",
   "eye_color": "blue",
   "_claim_names": {
     "payment_info": "src1",
     "shipping_address": "src1",
     "credit_score": "src2"
    },
   "_claim_sources": {
     "src1": {"endpoint":
                "https://bank.example.com/claim_source"},
     "src2": {"endpoint":
                "https://creditagency.example.com/claims_here",
              "access_token": "ksj3n283dke"}
   }
  }
Note that not returning phone_number, which is held by Claims Provider B, demonstrates that not all Claims held by a utilized Claims Provider need be included.


 TOC
5.7.  Claim Stability and Uniqueness
The sub (subject) and iss (issuer) Claims from the ID Token, used together, are the only Claims that an RP can rely upon as a stable identifier for the End-User, since the sub Claim MUST be locally unique and never reassigned within the Issuer for a particular End-User, as described in Section 2. Therefore, the only guaranteed unique identifier for a given End-User is the combination of the iss Claim and the sub Claim.

All other Claims carry no such guarantees across different issuers in terms of stability over time or uniqueness across users, and Issuers are permitted to apply local restrictions and policies. For instance, an Issuer MAY re-use an email Claim Value across different End-Users at different points in time, and the claimed email address for a given End-User MAY change over time. Therefore, other Claims such as email, phone_number, preferred_username, and name MUST NOT be used as unique identifiers for the End-User, whether obtained from the ID Token or the UserInfo Endpoint.


 TOC
6.  Passing Request Parameters as JWTs
OpenID Connect defines the following Authorization Request parameters to enable Authentication Requests to be signed and optionally encrypted:

request
OPTIONAL. This parameter enables OpenID Connect requests to be passed in a single, self-contained parameter and to be optionally signed and/or encrypted. The parameter value is a Request Object value, as specified in Section 6.1. It represents the request as a JWT whose Claims are the request parameters.
request_uri
OPTIONAL. This parameter enables OpenID Connect requests to be passed by reference, rather than by value. The request_uri value is a URL referencing a resource containing a Request Object value, which is a JWT containing the request parameters. This URL MUST use the https scheme unless the target Request Object is signed in a way that is verifiable by the OP.

Requests using these parameters are represented as JWTs, which are respectively passed by value or by reference. The ability to pass requests by reference is particularly useful for large requests. If one of these parameters is used, the other MUST NOT be used in the same request.

Note that the Request Objects defined here are compatible with those specified by The OAuth 2.0 Authorization Framework: JWT-Secured Authorization Request (JAR) [RFC9101].


 TOC
6.1.  Passing a Request Object by Value
The request Authorization Request parameter enables OpenID Connect requests to be passed in a single, self-contained parameter and to be optionally signed and/or encrypted. It represents the request as a JWT whose Claims are the request parameters specified in Section 3.1.2. This JWT is called a Request Object.

Support for the request parameter is OPTIONAL. The request_parameter_supported Discovery result indicates whether the OP supports this parameter. Should an OP not support this parameter and an RP uses it, the OP MUST return the request_not_supported error.

When the request parameter is used, the OpenID Connect request parameter values contained in the JWT supersede those passed using the OAuth 2.0 request syntax. However, parameters MAY also be passed using the OAuth 2.0 request syntax even when a Request Object is used; this would typically be done to enable a cached, pre-signed (and possibly pre-encrypted) Request Object value to be used containing the fixed request parameters, while parameters that can vary with each request, such as state and nonce, are passed as OAuth 2.0 parameters.

So that the request is a valid OAuth 2.0 Authorization Request, values for the response_type and client_id parameters MUST be included using the OAuth 2.0 request syntax, since they are REQUIRED by OAuth 2.0. The values for these parameters MUST match those in the Request Object, if present.

Even if a scope parameter is present in the Request Object value, a scope parameter MUST always be passed using the OAuth 2.0 request syntax containing the openid scope value to indicate to the underlying OAuth 2.0 logic that this is an OpenID Connect request.

The Request Object MAY be signed or unsigned (unsecured). When it is unsecured, this is indicated by use of the none algorithm [JWA] in the JOSE Header. If signed, the Request Object SHOULD contain the Claims iss (issuer) and aud (audience) as members. The iss value SHOULD be the Client ID of the RP, unless it was signed by a different party than the RP. The aud value SHOULD be or include the OP's Issuer Identifier URL.

The Request Object MAY also be encrypted using JWE [JWE] and MAY be encrypted without also being signed. If both signing and encryption are performed, it MUST be signed then encrypted, with the result being a Nested JWT, as defined in [JWT].

request and request_uri parameters MUST NOT be included in Request Objects.


The following is a non-normative example of the Claims in a Request Object before base64url-encoding and signing:

  {
   "iss": "s6BhdRkqt3",
   "aud": "https://server.example.com",
   "response_type": "code id_token",
   "client_id": "s6BhdRkqt3",
   "redirect_uri": "https://client.example.org/cb",
   "scope": "openid",
   "state": "af0ifjsldkj",
   "nonce": "n-0S6_WzA2Mj",
   "max_age": 86400,
   "claims":
    {
     "userinfo":
      {
       "given_name": {"essential": true},
       "nickname": null,
       "email": {"essential": true},
       "email_verified": {"essential": true},
       "picture": null
      },
     "id_token":
      {
       "gender": null,
       "birthdate": {"essential": true},
       "acr": {"values": ["urn:mace:incommon:iap:silver"]}
      }
    }
  }
Signing it with the RS256 algorithm results in this Request Object value (with line wraps within values for display purposes only):

  eyJhbGciOiJSUzI1NiIsImtpZCI6ImsyYmRjIn0.ew0KICJpc3MiOiAiczZCaGRSa3
  F0MyIsDQogImF1ZCI6ICJodHRwczovL3NlcnZlci5leGFtcGxlLmNvbSIsDQogInJl
  c3BvbnNlX3R5cGUiOiAiY29kZSBpZF90b2tlbiIsDQogImNsaWVudF9pZCI6ICJzNk
  JoZFJrcXQzIiwNCiAicmVkaXJlY3RfdXJpIjogImh0dHBzOi8vY2xpZW50LmV4YW1w
  bGUub3JnL2NiIiwNCiAic2NvcGUiOiAib3BlbmlkIiwNCiAic3RhdGUiOiAiYWYwaW
  Zqc2xka2oiLA0KICJub25jZSI6ICJuLTBTNl9XekEyTWoiLA0KICJtYXhfYWdlIjog
  ODY0MDAsDQogImNsYWltcyI6IA0KICB7DQogICAidXNlcmluZm8iOiANCiAgICB7DQ
  ogICAgICJnaXZlbl9uYW1lIjogeyJlc3NlbnRpYWwiOiB0cnVlfSwNCiAgICAgIm5p
  Y2tuYW1lIjogbnVsbCwNCiAgICAgImVtYWlsIjogeyJlc3NlbnRpYWwiOiB0cnVlfS
  wNCiAgICAgImVtYWlsX3ZlcmlmaWVkIjogeyJlc3NlbnRpYWwiOiB0cnVlfSwNCiAg
  ICAgInBpY3R1cmUiOiBudWxsDQogICAgfSwNCiAgICJpZF90b2tlbiI6IA0KICAgIH
  sNCiAgICAgImdlbmRlciI6IG51bGwsDQogICAgICJiaXJ0aGRhdGUiOiB7ImVzc2Vu
  dGlhbCI6IHRydWV9LA0KICAgICAiYWNyIjogeyJ2YWx1ZXMiOiBbInVybjptYWNlOm
  luY29tbW9uOmlhcDpzaWx2ZXIiXX0NCiAgICB9DQogIH0NCn0.nwwnNsk1-Zkbmnvs
  F6zTHm8CHERFMGQPhos-EJcaH4Hh-sMgk8ePrGhw_trPYs8KQxsn6R9Emo_wHwajyF
  KzuMXZFSZ3p6Mb8dkxtVyjoy2GIzvuJT_u7PkY2t8QU9hjBcHs68PkgjDVTrG1uRTx
  0GxFbuPbj96tVuj11pTnmFCUR6IEOXKYr7iGOCRB3btfJhM0_AKQUfqKnRlrRscc8K
  ol-cSLWoYE9l5QqholImzjT_cMnNIznW9E7CDyWXTsO70xnB4SkG6pXfLSjLLlxmPG
  iyon_-Te111V8uE83IlzCYIb_NMXvtTIVc1jpspnTSD7xMbpL-2QgwUsAlMGzw
The following RSA public key, represented in JWK format, can be used to validate the Request Object signature in this and subsequent Request Object examples (with line wraps within values for display purposes only):

  {
   "kty":"RSA",
   "kid":"k2bdc",
   "n":"y9Lqv4fCp6Ei-u2-ZCKq83YvbFEk6JMs_pSj76eMkddWRuWX2aBKGHAtKlE5P
        7_vn__PCKZWePt3vGkB6ePgzAFu08NmKemwE5bQI0e6kIChtt_6KzT5OaaXDF
        I6qCLJmk51Cc4VYFaxgqevMncYrzaW_50mZ1yGSFIQzLYP8bijAHGVjdEFgZa
        ZEN9lsn_GdWLaJpHrB3ROlS50E45wxrlg9xMncVb8qDPuXZarvghLL0HzOuYR
        adBJVoWZowDNTpKpk2RklZ7QaBO7XDv3uR7s_sf2g-bAjSYxYUGsqkNA9b3xV
        W53am_UZZ3tZbFTIh557JICWKHlWj5uzeJXaw",
   "e":"AQAB"
  }

 TOC
6.1.1.  Request using the "request" Request Parameter
The Client sends the Authorization Request to the Authorization Endpoint.


The following is a non-normative example of an Authorization Request using the request parameter (with line wraps within values for display purposes only):

  https://server.example.com/authorize?
    response_type=code%20id_token
    &client_id=s6BhdRkqt3
    &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb
    &scope=openid
    &state=af0ifjsldkj
    &nonce=n-0S6_WzA2Mj
    &request=eyJhbGciOiJSUzI1NiIsImtpZCI6ImsyYmRjIn0.ew0KICJpc3MiOiA
    iczZCaGRSa3F0MyIsDQogImF1ZCI6ICJodHRwczovL3NlcnZlci5leGFtcGxlLmN
    vbSIsDQogInJlc3BvbnNlX3R5cGUiOiAiY29kZSBpZF90b2tlbiIsDQogImNsaWV
    udF9pZCI6ICJzNkJoZFJrcXQzIiwNCiAicmVkaXJlY3RfdXJpIjogImh0dHBzOi8
    vY2xpZW50LmV4YW1wbGUub3JnL2NiIiwNCiAic2NvcGUiOiAib3BlbmlkIiwNCiA
    ic3RhdGUiOiAiYWYwaWZqc2xka2oiLA0KICJub25jZSI6ICJuLTBTNl9XekEyTWo
    iLA0KICJtYXhfYWdlIjogODY0MDAsDQogImNsYWltcyI6IA0KICB7DQogICAidXN
    lcmluZm8iOiANCiAgICB7DQogICAgICJnaXZlbl9uYW1lIjogeyJlc3NlbnRpYWw
    iOiB0cnVlfSwNCiAgICAgIm5pY2tuYW1lIjogbnVsbCwNCiAgICAgImVtYWlsIjo
    geyJlc3NlbnRpYWwiOiB0cnVlfSwNCiAgICAgImVtYWlsX3ZlcmlmaWVkIjogeyJ
    lc3NlbnRpYWwiOiB0cnVlfSwNCiAgICAgInBpY3R1cmUiOiBudWxsDQogICAgfSw
    NCiAgICJpZF90b2tlbiI6IA0KICAgIHsNCiAgICAgImdlbmRlciI6IG51bGwsDQo
    gICAgICJiaXJ0aGRhdGUiOiB7ImVzc2VudGlhbCI6IHRydWV9LA0KICAgICAiYWN
    yIjogeyJ2YWx1ZXMiOiBbInVybjptYWNlOmluY29tbW9uOmlhcDpzaWx2ZXIiXX0
    NCiAgICB9DQogIH0NCn0.nwwnNsk1-ZkbmnvsF6zTHm8CHERFMGQPhos-EJcaH4H
    h-sMgk8ePrGhw_trPYs8KQxsn6R9Emo_wHwajyFKzuMXZFSZ3p6Mb8dkxtVyjoy2
    GIzvuJT_u7PkY2t8QU9hjBcHs68PkgjDVTrG1uRTx0GxFbuPbj96tVuj11pTnmFC
    UR6IEOXKYr7iGOCRB3btfJhM0_AKQUfqKnRlrRscc8Kol-cSLWoYE9l5QqholImz
    jT_cMnNIznW9E7CDyWXTsO70xnB4SkG6pXfLSjLLlxmPGiyon_-Te111V8uE83Il
    zCYIb_NMXvtTIVc1jpspnTSD7xMbpL-2QgwUsAlMGzw

 TOC
6.2.  Passing a Request Object by Reference
The request_uri Authorization Request parameter enables OpenID Connect requests to be passed by reference, rather than by value. This parameter is used identically to the request parameter, other than that the Request Object value is retrieved from the resource at the specified URL, rather than passed by value.

The request_uri_parameter_supported Discovery result indicates whether the OP supports this parameter. Should an OP not support this parameter and an RP uses it, the OP MUST return the request_uri_not_supported error.

When the request_uri parameter is used, the OpenID Connect request parameter values contained in the referenced JWT supersede those passed using the OAuth 2.0 request syntax. However, parameters MAY also be passed using the OAuth 2.0 request syntax even when a request_uri is used; this would typically be done to enable a cached, pre-signed (and possibly pre-encrypted) Request Object value to be used containing the fixed request parameters, while parameters that can vary with each request, such as state and nonce, are passed as OAuth 2.0 parameters.

So that the request is a valid OAuth 2.0 Authorization Request, values for the response_type and client_id parameters MUST be included using the OAuth 2.0 request syntax, since they are REQUIRED by OAuth 2.0. The values for these parameters MUST match those in the Request Object, if present.

Even if a scope parameter is present in the referenced Request Object, a scope parameter MUST always be passed using the OAuth 2.0 request syntax containing the openid scope value to indicate to the underlying OAuth 2.0 logic that this is an OpenID Connect request.

Servers MAY cache the contents of the resources referenced by Request URIs. If the contents of the referenced resource could ever change, the URI SHOULD include the base64url-encoded SHA-256 hash of the referenced resource contents as the fragment component of the URI. If the fragment value used for a URI changes, that signals the server that any cached value for that URI with the old fragment value is no longer valid.

Note that Clients MAY pre-register request_uri values using the request_uris parameter defined in Section 2.1 of the OpenID Connect Dynamic Client Registration 1.0 [OpenID.Registration] specification. OPs can require that request_uri values used be pre-registered with the require_request_uri_registration discovery parameter.

The entire Request URI SHOULD NOT exceed 512 ASCII characters.

The contents of the resource referenced by the URL MUST be a Request Object. The scheme used in the request_uri value MUST be https, unless the target Request Object is signed in a way that is verifiable by the Authorization Server. The request_uri value MUST be reachable by the Authorization Server and SHOULD be reachable by the Client.


The following is a non-normative example of the contents of a Request Object resource that can be referenced by a request_uri (with line wraps within values for display purposes only):

  eyJhbGciOiJSUzI1NiIsImtpZCI6ImsyYmRjIn0.ew0KICJpc3MiOiAiczZCaGRSa3
  F0MyIsDQogImF1ZCI6ICJodHRwczovL3NlcnZlci5leGFtcGxlLmNvbSIsDQogInJl
  c3BvbnNlX3R5cGUiOiAiY29kZSBpZF90b2tlbiIsDQogImNsaWVudF9pZCI6ICJzNk
  JoZFJrcXQzIiwNCiAicmVkaXJlY3RfdXJpIjogImh0dHBzOi8vY2xpZW50LmV4YW1w
  bGUub3JnL2NiIiwNCiAic2NvcGUiOiAib3BlbmlkIiwNCiAic3RhdGUiOiAiYWYwaW
  Zqc2xka2oiLA0KICJub25jZSI6ICJuLTBTNl9XekEyTWoiLA0KICJtYXhfYWdlIjog
  ODY0MDAsDQogImNsYWltcyI6IA0KICB7DQogICAidXNlcmluZm8iOiANCiAgICB7DQ
  ogICAgICJnaXZlbl9uYW1lIjogeyJlc3NlbnRpYWwiOiB0cnVlfSwNCiAgICAgIm5p
  Y2tuYW1lIjogbnVsbCwNCiAgICAgImVtYWlsIjogeyJlc3NlbnRpYWwiOiB0cnVlfS
  wNCiAgICAgImVtYWlsX3ZlcmlmaWVkIjogeyJlc3NlbnRpYWwiOiB0cnVlfSwNCiAg
  ICAgInBpY3R1cmUiOiBudWxsDQogICAgfSwNCiAgICJpZF90b2tlbiI6IA0KICAgIH
  sNCiAgICAgImdlbmRlciI6IG51bGwsDQogICAgICJiaXJ0aGRhdGUiOiB7ImVzc2Vu
  dGlhbCI6IHRydWV9LA0KICAgICAiYWNyIjogeyJ2YWx1ZXMiOiBbInVybjptYWNlOm
  luY29tbW9uOmlhcDpzaWx2ZXIiXX0NCiAgICB9DQogIH0NCn0.nwwnNsk1-Zkbmnvs
  F6zTHm8CHERFMGQPhos-EJcaH4Hh-sMgk8ePrGhw_trPYs8KQxsn6R9Emo_wHwajyF
  KzuMXZFSZ3p6Mb8dkxtVyjoy2GIzvuJT_u7PkY2t8QU9hjBcHs68PkgjDVTrG1uRTx
  0GxFbuPbj96tVuj11pTnmFCUR6IEOXKYr7iGOCRB3btfJhM0_AKQUfqKnRlrRscc8K
  ol-cSLWoYE9l5QqholImzjT_cMnNIznW9E7CDyWXTsO70xnB4SkG6pXfLSjLLlxmPG
  iyon_-Te111V8uE83IlzCYIb_NMXvtTIVc1jpspnTSD7xMbpL-2QgwUsAlMGzw

 TOC
6.2.1.  URI Referencing the Request Object
The Client stores the Request Object resource either locally or remotely at a URL the Server can access. This URL is the Request URI, request_uri.

If the Request Object includes requested values for Claims, it MUST NOT be revealed to anybody but the Authorization Server. As such, the request_uri MUST have appropriate entropy for its lifetime. It is RECOMMENDED that it be removed if it is known that it will not be used again or after a reasonable timeout unless access control measures are taken.

The following is a non-normative example of a Request URI value (with line wraps within values for display purposes only):

  https://client.example.org/request.jwt#
    GkurKxf5T0Y-mnPFCHqWOMiZi4VS138cQO_V7PZHAdM

 TOC
6.2.2.  Request using the "request_uri" Request Parameter
The Client sends the Authorization Request to the Authorization Endpoint.

The following is a non-normative example of an Authorization Request using the request_uri parameter (with line wraps within values for display purposes only):

  https://server.example.com/authorize?
    response_type=code%20id_token
    &client_id=s6BhdRkqt3
    &request_uri=https%3A%2F%2Fclient.example.org%2Frequest.jwt
    %23GkurKxf5T0Y-mnPFCHqWOMiZi4VS138cQO_V7PZHAdM
    &state=af0ifjsldkj&nonce=n-0S6_WzA2Mj
    &scope=openid

 TOC
6.2.3.  Authorization Server Fetches Request Object
Upon receipt of the Request, the Authorization Server MUST send an HTTP GET request to the request_uri to retrieve the referenced Request Object, unless it is already cached, and parse it to recreate the Authorization Request parameters.

Note that the RP SHOULD use a unique URI for each request utilizing distinct parameters, or otherwise prevent the Authorization Server from caching the request_uri.

The following is a non-normative example of this fetch process:

  GET /request.jwt HTTP/1.1
  Host: client.example.org

 TOC
6.2.4.  "request_uri" Rationale
There are several reasons that one might choose to use the request_uri parameter:


The set of request parameters can become large and can exceed browser URI size limitations. Passing the request parameters by reference can solve this problem.
Passing a request_uri value, rather than a complete request by value, can reduce request latency.
Most requests for Claims from an RP are constant. The request_uri is a way of creating and sometimes also signing and encrypting a constant set of request parameters in advance. (The request_uri value becomes an "artifact" representing a particular fixed set of request parameters.)
Pre-registering a fixed set of request parameters at Registration time enables OPs to cache and pre-validate the request parameters at Registration time, meaning they need not be retrieved at request time.
Pre-registering a fixed set of request parameters at Registration time enables OPs to vet the contents of the request from consumer protection and other points of views, either itself or by utilizing a third party.


 TOC
6.3.  Validating JWT-Based Requests
When the request or request_uri Authorization Request parameters are used, additional steps must be performed to validate the Authentication Request beyond those specified in Sections 3.1.2.2, 3.2.2.2, or 3.3.2.2. These steps are to validate the JWT containing the Request Object and to validate the Request Object itself.


 TOC
6.3.1.  Encrypted Request Object
If the Authorization Server has advertised JWE encryption algorithms in the request_object_encryption_alg_values_supported and request_object_encryption_enc_values_supported elements of its Discovery document [OpenID.Discovery], or has supplied encryption algorithms by other means, these are used by the Client to encrypt the JWT.

The Authorization Server MUST decrypt the JWT in accordance with the JSON Web Encryption [JWE] specification. The result MAY be either a signed or unsigned (unsecured) Request Object. In the former case, signature validation MUST be performed as defined in Section 6.3.2.

The Authorization Server MUST return an error if decryption fails.


 TOC
6.3.2.  Signed Request Object
To perform Signature Validation, the alg Header Parameter in the JOSE Header MUST match the value of the request_object_signing_alg set during Client Registration [OpenID.Registration] or a value that was pre-registered by other means. The signature MUST be validated against the appropriate key for that client_id and algorithm.

The Authorization Server MUST return an error if signature validation fails.


 TOC
6.3.3.  Request Parameter Assembly and Validation
The Authorization Server MUST assemble the set of Authorization Request parameters to be used from the Request Object value and the OAuth 2.0 Authorization Request parameters (minus the request or request_uri parameters). If the same parameter exists both in the Request Object and the OAuth Authorization Request parameters, the parameter in the Request Object is used. Using the assembled set of Authorization Request parameters, the Authorization Server then validates the request the normal manner for the flow being used, as specified in Sections 3.1.2.2, 3.2.2.2, or 3.3.2.2.


 TOC
7.  Self-Issued OpenID Provider
OpenID Connect supports Self-Issued OpenID Providers - personal, self-hosted OPs that issue self-signed ID Tokens. Self-Issued OPs use the special Issuer Identifier https://self-issued.me.

The messages used to communicate with Self-Issued OPs are mostly the same as those used to communicate with other OPs. Specifications for the few additional parameters used and for the values of some parameters in the Self-Issued case are defined in this section.


 TOC
7.1.  Self-Issued OpenID Provider Discovery
If the input identifier for the discovery process contains the domain self-issued.me, dynamic discovery is not performed. Instead, then the following static configuration values are used:


  {
   "authorization_endpoint":
     "openid:",
   "issuer":
     "https://self-issued.me",
   "scopes_supported":
     ["openid", "profile", "email", "address", "phone"],
   "response_types_supported":
     ["id_token"],
   "subject_types_supported":
     ["pairwise"],
   "id_token_signing_alg_values_supported":
     ["RS256"],
   "request_object_signing_alg_values_supported":
     ["none", "RS256"]
  }

NOTE: The OpenID Foundation plans to host the OpenID Provider site https://self-issued.me/, including its WebFinger service, so that performing discovery on it returns the above static discovery information, enabling RPs to not need any special processing for discovery of the Self-Issued OP. This site will be hosted on an experimental basis. Production implementations should not take a dependency upon it without a subsequent commitment by the OpenID Foundation to host the site in a manner intended for production use.


 TOC
7.2.  Self-Issued OpenID Provider Registration
When using a Self-Issued OP, registration is not required. The Client can proceed without registration as if it had registered with the OP and obtained the following Client Registration Response:


client_id
redirect_uri value of the Client.
client_secret_expires_at
0

NOTE: The OpenID Foundation plans to host the (stateless) endpoint https://self-issued.me/registration/1.0/ that returns the response above, enabling RPs to not need any special processing for registration with the Self-Issued OP. This site will be hosted on an experimental basis. Production implementations should not take a dependency upon it without a subsequent commitment by the OpenID Foundation to host the site in a manner intended for production use.


 TOC
7.2.1.  Providing Information with the "registration" Request Parameter
OpenID Connect defines the following Authorization Request parameter to enable Clients to provide additional registration information to Self-Issued OpenID Providers:

registration
OPTIONAL. This parameter is used by the Client to provide information about itself to a Self-Issued OP that would normally be provided to an OP during Dynamic Client Registration. The value is a JSON object containing Client metadata values, as defined in Section 2.1 of the OpenID Connect Dynamic Client Registration 1.0 [OpenID.Registration] specification. The registration parameter SHOULD NOT be used when the OP is not a Self-Issued OP.

None of this information is REQUIRED by Self-Issued OPs, so the use of this parameter is OPTIONAL.

The registration parameter value is represented in an OAuth 2.0 request as a UTF-8 encoded JSON object (which ends up being form-urlencoded when passed as an OAuth parameter). When used in a Request Object value, per Section 6.1, the JSON object is used as the value of the registration member.

The Registration parameters that would typically be used in requests to Self-Issued OPs are policy_uri, tos_uri, and logo_uri. If the Client uses more than one Redirection URI, the redirect_uris parameter would be used to register them. Finally, if the Client is requesting encrypted responses, it would typically use the jwks_uri, id_token_encrypted_response_alg and id_token_encrypted_response_enc parameters.


 TOC
7.3.  Self-Issued OpenID Provider Request
The self-issued OP's Authorization Endpoint is the URI openid:.

The Client sends the Authentication Request to the Authorization Endpoint with the following parameters:


scope
REQUIRED. scope parameter value, as specified in Section 3.1.2.
response_type
REQUIRED. Constant string value id_token.
client_id
REQUIRED. Client ID value for the Client, which in this case contains the redirect_uri value of the Client. Since the Client's redirect_uri URI value is communicated as the Client ID, a redirect_uri parameter is NOT REQUIRED to also be included in the request.
id_token_hint
OPTIONAL. id_token_hint parameter value, as specified in Section 3.1.2. Encrypting content to Self-Issued OPs is not supported.
claims
OPTIONAL. claims parameter value, as specified in Section 5.5.
registration
OPTIONAL. This parameter is used by the Client to provide information about itself to a Self-Issued OP that would normally be provided to an OP during Dynamic Client Registration, as specified in Section 7.2.1.
request
OPTIONAL. Request Object value, as specified in Section 6.1. Encrypting content to Self-Issued OPs is not supported.

Other parameters MAY be sent. Note that all Claims are returned in the ID Token.

The entire URL MUST NOT exceed 2048 ASCII characters.

The following is a non-normative example HTTP 302 redirect response by the Client, which triggers the User Agent to make an Authentication Request to the Self-Issued OpenID Provider (with line wraps within values for display purposes only):

  HTTP/1.1 302 Found
  Location: openid://?
    response_type=id_token
    &client_id=https%3A%2F%2Fclient.example.org%2Fcb
    &scope=openid%20profile
    &state=af0ifjsldkj
    &nonce=n-0S6_WzA2Mj
    &registration=%7B%22logo_uri%22%3A%22https%3A%2F%2F
      client.example.org%2Flogo.png%22%7D

 TOC
7.4.  Self-Issued OpenID Provider Response
OpenID Connect defines the following Claim for use in Self-Issued OpenID Provider Responses:

sub_jwk
REQUIRED. Public key used to check the signature of an ID Token issued by a Self-Issued OpenID Provider, as specified in Section 7. The key is a bare key in JWK [JWK] format (not an X.509 certificate value). The sub_jwk value is a JSON object. Use of the sub_jwk Claim is NOT RECOMMENDED when the OP is not Self-Issued.

The Self-Issued OpenID Provider response is the same as the normal Implicit Flow response with the following refinements. Since it is an Implicit Flow response, the response parameters will be returned in the URL fragment component, unless a different Response Mode was specified.


The iss (issuer) Claim Value is https://self-issued.me.
A sub_jwk Claim is present, with its value being the public key used to check the signature of the ID Token.
The sub (subject) Claim value is the base64url-encoded representation of the thumbprint of the key in the sub_jwk Claim. This thumbprint value is computed as the SHA-256 hash of the octets of the UTF-8 representation of a JWK constructed containing only the REQUIRED members to represent the key, with the member names sorted into lexicographic order, and with no whitespace or line breaks. For instance, when the kty value is RSA, the member names e, kty, and n are the ones present in the constructed JWK used in the thumbprint computation and appear in that order; when the kty value is EC, the member names crv, kty, x, and y are present in that order. Note that this thumbprint calculation is the same as that defined in the JWK Thumbprint [JWK.Thumbprint] specification.
No Access Token is returned for accessing a UserInfo Endpoint, so all Claims returned MUST be in the ID Token.


 TOC
7.5.  Self-Issued ID Token Validation
To validate the ID Token received, the Client MUST do the following:


The Client MUST validate that the value of the iss (issuer) Claim is https://self-issued.me. If iss contains a different value, the ID Token is not Self-Issued, and instead it MUST be validated according to Section 3.1.3.7.
The Client MUST validate that the aud (audience) Claim contains the value of the redirect_uri that the Client sent in the Authentication Request as an audience.
The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the alg Header Parameter of the JOSE Header, using the key in the sub_jwk Claim; the key is a bare key in JWK format (not an X.509 certificate value).
The alg value SHOULD be the default of RS256. It MAY also be ES256.
The Client MUST validate that the sub Claim value is the base64url-encoded representation of the thumbprint of the key in the sub_jwk Claim, as specified in Section 7.4.
The current time MUST be before the time represented by the exp Claim (possibly allowing for some small leeway to account for clock skew).
The iat Claim can be used to reject tokens that were issued too far away from the current time, limiting the amount of time that nonces need to be stored to prevent attacks. The acceptable range is Client specific.
A nonce Claim MUST be present and its value checked to verify that it is the same value as the one that was sent in the Authentication Request. The Client SHOULD check the nonce value for replay attacks. The precise method for detecting replay attacks is Client specific.

The following is a non-normative example of a base64url-decoded Self-Issued ID Token (with line wraps within values for display purposes only):

  {
   "iss": "https://self-issued.me",
   "sub": "NzbLsXh8uDCcd-6MNwXF4W_7noWXFZAfHkxZsRGC9Xs",
   "aud": "https://client.example.org/cb",
   "nonce": "n-0S6_WzA2Mj",
   "exp": 1311281970,
   "iat": 1311280970,
   "sub_jwk": {
     "kty":"RSA",
     "n": "0vx7agoebGcQSuuPiLJXZptN9nndrQmbXEps2aiAFbWhM78LhWx
     4cbbfAAtVT86zwu1RK7aPFFxuhDR1L6tSoc_BJECPebWKRXjBZCiFV4n3oknjhMs
     tn64tZ_2W-5JsGY4Hc5n9yBXArwl93lqt7_RN5w6Cf0h4QyQ5v-65YGjQR0_FDW2
     QvzqY368QQMicAtaSqzs8KJZgnYb9c7d0zgdAZHzu6qMQvRL5hajrn1n91CbOpbI
     SD08qNLyrdkt-bFTWhAI4vMQFh6WeZu0fM4lFd2NcRwr3XPksINHaQ-G_xBniIqb
     w0Ls1jF44-csFCur-kEgU8awapJzKnqDKgw",
     "e":"AQAB"
    }
  }

 TOC
8.  Subject Identifier Types
A Subject Identifier is a locally unique and never reassigned identifier within the Issuer for the End-User, which is intended to be consumed by the Client. Two Subject Identifier types are defined by this specification:

public
This provides the same sub (subject) value to all Clients. It is the default if the provider has no subject_types_supported element in its discovery document.
pairwise
This provides a different sub value to each Client, so as not to enable Clients to correlate the End-User's activities without permission.

The OpenID Provider's Discovery document MUST list its supported Subject Identifier types in the subject_types_supported element. If there is more than one type listed in the array, the Client MAY elect to provide its preferred identifier type using the subject_type parameter during Registration.


 TOC
8.1.  Pairwise Identifier Algorithm
When pairwise Subject Identifiers are used, the OpenID Provider MUST calculate a unique sub (subject) value for each Sector Identifier. The Subject Identifier value MUST NOT be reversible by any party other than the OpenID Provider.

Providers that use pairwise sub values and support Dynamic Client Registration [OpenID.Registration] SHOULD use the sector_identifier_uri parameter. It provides a way for a group of websites under common administrative control to have consistent pairwise sub values independent of the individual domain names. It also provides a way for Clients to change redirect_uri domains without having to re-register all of their users.

If the Client has not provided a value for sector_identifier_uri in Dynamic Client Registration [OpenID.Registration], the Sector Identifier used for pairwise identifier calculation is the host component of the registered redirect_uri. If there are multiple hostnames in the registered redirect_uris, the Client MUST register a sector_identifier_uri.

When a sector_identifier_uri is provided, the host component of that URL is used as the Sector Identifier for the pairwise identifier calculation. The value of the sector_identifier_uri MUST be a URL using the https scheme that points to a JSON file containing an array of redirect_uri values. The values of the registered redirect_uris MUST be included in the elements of the array.

Any algorithm with the following properties can be used by OpenID Providers to calculate pairwise Subject Identifiers:

The Subject Identifier value MUST NOT be reversible by any party other than the OpenID Provider.
Distinct Sector Identifier values MUST result in distinct Subject Identifier values.
The algorithm MUST be deterministic.

Three example methods are:

The Sector Identifier can be concatenated with a local account ID and a salt value that is kept secret by the Provider. The concatenated string is then hashed using an appropriate algorithm.

Calculate sub = SHA-256 ( sector_identifier || local_account_id || salt ).

The Sector Identifier can be concatenated with a local account ID and a salt value that is kept secret by the Provider. The concatenated string is then encrypted using an appropriate algorithm.

Calculate sub = AES-128 ( sector_identifier || local_account_id || salt ).

The Issuer creates a Globally Unique Identifier (GUID) for the pair of Sector Identifier and local account ID and stores this value.


 TOC
9.  Client Authentication
This section defines a set of Client Authentication methods that are used by Clients to authenticate to the Authorization Server when using the Token Endpoint. During Client Registration, the RP (Client) MAY register a Client Authentication method. If no method is registered, the default method is client_secret_basic.

These Client Authentication methods are:


client_secret_basic
Clients that have received a client_secret value from the Authorization Server authenticate with the Authorization Server in accordance with Section 2.3.1 of OAuth 2.0 [RFC6749] using the HTTP Basic authentication scheme.
client_secret_post
Clients that have received a client_secret value from the Authorization Server, authenticate with the Authorization Server in accordance with Section 2.3.1 of OAuth 2.0 [RFC6749] by including the Client Credentials in the request body.
client_secret_jwt
Clients that have received a client_secret value from the Authorization Server create a JWT using an HMAC SHA algorithm, such as HMAC SHA-256. The HMAC (Hash-based Message Authentication Code) is calculated using the octets of the UTF-8 representation of the client_secret as the shared key.
The Client authenticates in accordance with JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants [OAuth.JWT] and Assertion Framework for OAuth 2.0 Client Authentication and Authorization Grants [OAuth.Assertions]. The JWT MUST contain the following REQUIRED Claim Values and MAY contain the following OPTIONAL Claim Values:
iss
REQUIRED. Issuer. This MUST contain the client_id of the OAuth Client.
sub
REQUIRED. Subject. This MUST contain the client_id of the OAuth Client.
aud
REQUIRED. Audience. The aud (audience) Claim. Value that identifies the Authorization Server as an intended audience. The Authorization Server MUST verify that it is an intended audience for the token. The Audience SHOULD be the URL of the Authorization Server's Token Endpoint.
jti
REQUIRED. JWT ID. A unique identifier for the token, which can be used to prevent reuse of the token. These tokens MUST only be used once, unless conditions for reuse were negotiated between the parties; any such negotiation is beyond the scope of this specification.
exp
REQUIRED. Expiration time on or after which the JWT MUST NOT be accepted for processing.
iat
OPTIONAL. Time at which the JWT was issued.
The JWT MAY contain other Claims. Any Claims used that are not understood MUST be ignored.
The authentication token MUST be sent as the value of the [OAuth.Assertions] client_assertion parameter.
The value of the [OAuth.Assertions] client_assertion_type parameter MUST be "urn:ietf:params:oauth:client-assertion-type:jwt-bearer", per [OAuth.JWT].
private_key_jwt
Clients that have registered a public key sign a JWT using that key. The Client authenticates in accordance with JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants [OAuth.JWT] and Assertion Framework for OAuth 2.0 Client Authentication and Authorization Grants [OAuth.Assertions]. The JWT MUST contain the following REQUIRED Claim Values and MAY contain the following OPTIONAL Claim Values:
iss
REQUIRED. Issuer. This MUST contain the client_id of the OAuth Client.
sub
REQUIRED. Subject. This MUST contain the client_id of the OAuth Client.
aud
REQUIRED. Audience. The aud (audience) Claim. Value that identifies the Authorization Server as an intended audience. The Authorization Server MUST verify that it is an intended audience for the token. The Audience SHOULD be the URL of the Authorization Server's Token Endpoint.
jti
REQUIRED. JWT ID. A unique identifier for the token, which can be used to prevent reuse of the token. These tokens MUST only be used once, unless conditions for reuse were negotiated between the parties; any such negotiation is beyond the scope of this specification.
exp
REQUIRED. Expiration time on or after which the JWT MUST NOT be accepted for processing.
iat
OPTIONAL. Time at which the JWT was issued.
The JWT MAY contain other Claims. Any Claims used that are not understood MUST be ignored.
The authentication token MUST be sent as the value of the [OAuth.Assertions] client_assertion parameter.
The value of the [OAuth.Assertions] client_assertion_type parameter MUST be "urn:ietf:params:oauth:client-assertion-type:jwt-bearer", per [OAuth.JWT].
For example (with line wraps within values for display purposes only):

  POST /token HTTP/1.1
  Host: server.example.com
  Content-Type: application/x-www-form-urlencoded

  grant_type=authorization_code&
    code=i1WsRn1uB1&
    client_id=s6BhdRkqt3&
    client_assertion_type=
    urn%3Aietf%3Aparams%3Aoauth%3Aclient-assertion-type%3Ajwt-bearer&
    client_assertion=PHNhbWxwOl ... ZT
none
The Client does not authenticate itself at the Token Endpoint, either because it uses only the Implicit Flow (and so does not use the Token Endpoint) or because it is a Public Client with no Client Secret or other authentication mechanism.


 TOC
10.  Signatures and Encryption
Depending on the transport through which the messages are sent, the integrity of the message might not be guaranteed and the originator of the message might not be authenticated. To mitigate these risks, ID Token, UserInfo Response, Request Object, and Client Authentication JWT values can utilize JSON Web Signature (JWS) [JWS] to sign their contents. To achieve message confidentiality, these values can also use JSON Web Encryption (JWE) [JWE] to encrypt their contents.

When the message is both signed and encrypted, it MUST be signed first and then encrypted, per Section 16.14, with the result being a Nested JWT, as specified in [JWT]. Note that all JWE encryption methods perform integrity checking.

The OP advertises its supported signing and encryption algorithms in its Discovery document or may supply this information by other means. The RP declares its required signing and encryption algorithms in its Dynamic Registration request or may communicate this information by other means.

The OP advertises its public keys via its Discovery document or may supply this information by other means. The RP declares its public keys via its Dynamic Registration request or may communicate this information by other means.


 TOC
10.1.  Signing
The signing party MUST select a signature algorithm based on the algorithms supported by the recipient.


Asymmetric Signatures
When using RSA or ECDSA Signatures, the alg Header Parameter value of the JOSE Header MUST be set to an appropriate algorithm as defined in JSON Web Algorithms [JWA]. The private key used to sign the content MUST be associated with a public key used for signature verification published by the sender in its JWK Set document. If there are multiple keys in the referenced JWK Set document, a kid value MUST be provided in the JOSE Header. The key usage of the respective keys MUST support signing.
Symmetric Signatures
When using MAC-based signatures, the alg Header Parameter value of the JOSE Header MUST be set to a MAC algorithm, as defined in JSON Web Algorithms [JWA]. The MAC key used is the octets of the UTF-8 representation of the client_secret value. See Section 16.19 for a discussion of entropy requirements for client_secret values. Symmetric signatures MUST NOT be used by public (non-confidential) Clients because of their inability to keep secrets.

See Section 16.20 for Security Considerations about the need for signed requests.


 TOC
10.1.1.  Rotation of Asymmetric Signing Keys
Rotation of signing keys can be accomplished with the following approach. The signer publishes its keys in a JWK Set at its jwks_uri location and includes the kid of the signing key in the JOSE Header of each message to indicate to the verifier which key is to be used to validate the signature. Keys can be rolled over by periodically adding new keys to the JWK Set at the jwks_uri location. The signer can begin using a new key at its discretion and signals the change to the verifier using the kid value. The verifier knows to go back to the jwks_uri location to re-retrieve the keys when it sees an unfamiliar kid value. The JWK Set document at the jwks_uri SHOULD retain recently decommissioned signing keys for a reasonable period of time to facilitate a smooth transition.


 TOC
10.2.  Encryption
The encrypting party MUST select an encryption algorithm based on the algorithms supported by the recipient.


Asymmetric Encryption: RSA
The public key to which the content was encrypted MUST be a public key used for encryption published by the recipient in its JWK Set document. If there are multiple keys in the referenced JWK Set document, a kid value MUST be provided in the JOSE Header. Use the supported RSA encryption algorithm to encrypt a random Content Encryption Key to be used for encrypting the signed JWT. The key usage of the respective keys MUST include encryption.
Asymmetric Encryption: Elliptic Curve
Create an ephemeral Elliptic Curve public key for the epk element of the JOSE Header. The other public key used for the key agreement computation MUST be a public key published by the recipient in its JWK Set document. If there are multiple keys in the referenced JWK Set document, a kid value MUST be provided in the JOSE Header. Use the ECDH-ES algorithm to agree upon a Content Encryption Key to be used for encrypting the signed JWT. The key usage of the respective keys MUST support encryption.
Symmetric Encryption
The symmetric encryption key is derived from the client_secret value by using the left-most bits of a truncated SHA-2 hash of the octets of the UTF-8 representation of the client_secret. For keys of 256 or fewer bits, SHA-256 is used; for keys of 257-384 bits, SHA-384 is used; for keys of 385-512 bits, SHA-512 is used. The hash value MUST be truncated retaining the left-most bits to the appropriate bit length for the AES key wrapping or direct encryption algorithm used, for instance, truncating the SHA-256 hash to 128 bits for A128KW. If a symmetric key with greater than 512 bits is needed, a different method of deriving the key from the client_secret would have to be defined by an extension. Symmetric encryption MUST NOT be used by public (non-confidential) Clients because of their inability to keep secrets.

See Section 16.21 for Security Considerations about the need for encrypted requests.


 TOC
10.2.1.  Rotation of Asymmetric Encryption Keys
Rotating encryption keys necessarily uses a different process than the one for signing keys because the encrypting party starts the process and thus cannot rely on a change in kid as a signal that keys need to change. The encrypting party still uses the kid Header Parameter in the JWE to tell the decrypting party which private key to use to decrypt, however, the encrypting party needs to first select the most appropriate key from those provided in the JWK Set at the recipient's jwks_uri location.

To rotate keys, the decrypting party can publish new keys at its jwks_uri location and remove from the JWK Set those that are being decommissioned. The jwks_uri SHOULD include a Cache-Control header in the response that contains a max-age directive, as defined in RFC 7234 [RFC7234], which enables the encrypting party to safely cache the JWK Set and not have to re-retrieve the document for every encryption event. The decrypting party SHOULD remove decommissioned keys from the JWK Set referenced by jwks_uri but retain them internally for some reasonable period of time, coordinated with the cache duration, to facilitate a smooth transition between keys by allowing the encrypting party some time to obtain the new keys. The cache duration SHOULD also be coordinated with the issuance of new signing keys, as described in Section 10.1.1.


 TOC
11.  Offline Access
OpenID Connect defines the following scope value to request offline access:

offline_access
OPTIONAL. This scope value requests that an OAuth 2.0 Refresh Token be issued that can be used to obtain an Access Token that grants access to the End-User's UserInfo Endpoint even when the End-User is not present (not logged in).

When offline access is requested, a prompt parameter value of consent MUST be used unless other conditions for processing the request permitting offline access to the requested resources are in place. The OP MUST always obtain consent to returning a Refresh Token that enables offline access to the requested resources. A previously saved user consent is not always sufficient to grant offline access.

Upon receipt of a scope parameter containing the offline_access value, the Authorization Server:

MUST ensure that the prompt parameter contains consent unless other conditions for processing the request permitting offline access to the requested resources are in place; unless one or both of these conditions are fulfilled, then it MUST ignore the offline_access request,
MUST ignore the offline_access request unless the Client is using a response_type value that would result in an Authorization Code being returned,
MUST explicitly receive or have consent for offline access when the registered application_type is web,
SHOULD explicitly receive or have consent for offline access when the registered application_type is native.
The use of Refresh Tokens is not exclusive to the offline_access use case. The Authorization Server MAY grant Refresh Tokens in other contexts that are beyond the scope of this specification.


 TOC
12.  Using Refresh Tokens
A request to the Token Endpoint can also use a Refresh Token by using the grant_type value refresh_token, as described in Section 6 of OAuth 2.0 [RFC6749]. This section defines the behaviors for OpenID Connect Authorization Servers when Refresh Tokens are used.


 TOC
12.1.  Refresh Request
To refresh an Access Token, the Client MUST authenticate to the Token Endpoint using the authentication method registered for its client_id, as documented in Section 9. The Client sends the parameters via HTTP POST to the Token Endpoint using Form Serialization, per Section 13.2.

The following is a non-normative example of a Refresh Request (with line wraps within values for display purposes only):

  POST /token HTTP/1.1
  Host: server.example.com
  Content-Type: application/x-www-form-urlencoded

  client_id=s6BhdRkqt3
    &client_secret=some_secret12345
    &grant_type=refresh_token
    &refresh_token=8xLOxBtZp8
    &scope=openid%20profile
The Authorization Server MUST validate the Refresh Token, MUST verify that it was issued to the Client, and must verify that the Client successfully authenticated it has a Client Authentication method.


 TOC
12.2.  Successful Refresh Response
Upon successful validation of the Refresh Token, the response body is the Token Response of Section 3.1.3.3 except that it might not contain an id_token.

If an ID Token is returned as a result of a token refresh request, the following requirements apply:

its iss Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,
its sub Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,
its iat Claim MUST represent the time that the new ID Token is issued,
its aud Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,
if the ID Token contains an auth_time Claim, its value MUST represent the time of the original authentication - not the time that the new ID token is issued,
if the implementation is using extensions (which are beyond the scope of this specification) that result in the azp (authorized party) Claim being present, those extensions might specify that its azp Claim Value MUST be the same as in the ID Token issued when the original authentication occurred; likewise, they might specify that if no azp Claim was present in the original ID Token, one MUST NOT be present in the new ID Token,
it SHOULD NOT have a nonce Claim, even when the ID Token issued at the time of the original authentication contained nonce; however, if it is present, its value MUST be the same as in the ID Token issued at the time of the original authentication, and
otherwise, the same rules apply as apply when issuing an ID Token at the time of the original authentication.

The following is a non-normative example of a Refresh Response:

  HTTP/1.1 200 OK
  Content-Type: application/json
  Cache-Control: no-store

  {
   "access_token": "TlBN45jURg",
   "token_type": "Bearer",
   "refresh_token": "9yNOxJtZa5",
   "expires_in": 3600
  }

 TOC
12.3.  Refresh Error Response
If the Refresh Request is invalid or unauthorized, the Authorization Server returns the Token Error Response as defined in Section 5.2 of OAuth 2.0 [RFC6749].


 TOC
13.  Serializations
Messages are serialized using one of the following methods:

Query String Serialization
Form Serialization
JSON Serialization
This section describes the syntax of these serialization methods; other sections describe when they can and must be used. Note that not all methods can be used for all messages.


 TOC
13.1.  Query String Serialization
In order to serialize the parameters using the Query String Serialization, the Client constructs the string by adding the parameters and values to the query component of a URL using the application/x-www-form-urlencoded format as defined by [W3C.SPSD‑html401‑20180327]. Query String Serialization is typically used in HTTP GET requests. The same serialization method is also used when adding parameters to the fragment component of a URL.

The following is a non-normative example of this serialization (with line wraps within values for display purposes only):

  GET /authorize?
    response_type=code
    &scope=openid
    &client_id=s6BhdRkqt3
    &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb HTTP/1.1
  Host: server.example.com

 TOC
13.2.  Form Serialization
Parameters and their values are Form Serialized by adding the parameter names and values to the entity body of the HTTP request using the application/x-www-form-urlencoded format as defined by [W3C.SPSD‑html401‑20180327]. Form Serialization is typically used in HTTP POST requests.

The following is a non-normative example of this serialization (with line wraps within values for display purposes only):

  POST /authorize HTTP/1.1
  Host: server.example.com
  Content-Type: application/x-www-form-urlencoded

  response_type=code
    &scope=openid
    &client_id=s6BhdRkqt3
    &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb

 TOC
13.3.  JSON Serialization
The parameters are serialized into a JSON object structure by adding each parameter at the highest structure level. Parameter names and string values are represented as JSON strings. Numerical values are represented as JSON numbers. Boolean values are represented as JSON booleans. Omitted parameters and parameters with no value SHOULD be omitted from the object and not represented by a JSON null value, unless otherwise specified. A parameter MAY have a JSON object or a JSON array as its value.

The following is a non-normative example of this serialization:

  {
   "access_token": "SlAV32hkKG",
   "token_type": "Bearer",
   "expires_in": 3600,
   "refresh_token": "8xLOxBtZp8"
  }

 TOC
14.  String Operations
Processing some OpenID Connect messages requires comparing values in the messages to known values. For example, the Claim Names returned by the UserInfo Endpoint might be compared to specific Claim Names such as sub. Comparing Unicode [UNICODE] strings, however, has significant security implications.

Therefore, comparisons between JSON strings and other Unicode strings MUST be performed as specified below:

Remove any JSON applied escaping to produce an array of Unicode code points.
Unicode Normalization [USA15] MUST NOT be applied at any point to either the JSON string or to the string it is to be compared against.
Comparisons between the two strings MUST be performed as a Unicode code point to code point equality comparison.

In several places, this specification uses space-delimited lists of strings. In all such cases, a single ASCII space character (0x20) MUST be used as the delimiter.


 TOC
15.  Implementation Considerations
This specification defines features used by both Relying Parties and OpenID Providers. It is expected that some OpenID Providers will require static, out-of-band configuration of RPs using them, whereas others will support dynamic usage by RPs without a pre-established relationship between them. For that reason, the mandatory-to-implement features for OPs are listed below in two groups: the first for all OPs and the second for "Dynamic" OpenID Providers.


 TOC
15.1.  Mandatory to Implement Features for All OpenID Providers
All OpenID Providers MUST implement the following features defined in this specification. This list augments the set of features that are already listed elsewhere as being "REQUIRED" or are described with a "MUST", and so is not, by itself, a comprehensive set of implementation requirements for OPs.


Signing ID Tokens with RSA SHA-256
OPs MUST support signing ID Tokens with the RSA SHA-256 algorithm (an alg value of RS256), unless the OP only supports returning ID Tokens from the Token Endpoint (as is the case for the Authorization Code Flow) and only allows Clients to register specifying none as the requested ID Token signing algorithm.
Prompt Parameter
OPs MUST support the prompt parameter, as defined in Section 3.1.2, including the specified user interface behaviors such as none and login.
Display Parameter
OPs MUST support the display parameter, as defined in Section 3.1.2. (Note that the minimum level of support required for this parameter is simply that its use must not result in an error.)
Preferred Locales
OPs MUST support requests for preferred languages and scripts for the user interface and for Claims via the ui_locales and claims_locales request parameters, as defined in Section 3.1.2. (Note that the minimum level of support required for these parameters is simply to have their use not result in errors.)
Authentication Time
OPs MUST support returning the time at which the End-User authenticated via the auth_time Claim, when requested, as defined in Section 2.
Maximum Authentication Age
OPs MUST support enforcing a maximum authentication age via the max_age parameter, as defined in Section 3.1.2.
Authentication Context Class Reference
OPs MUST support requests for specific Authentication Context Class Reference values via the acr_values parameter, as defined in Section 3.1.2. (Note that the minimum level of support required for this parameter is simply to have its use not result in an error.)


 TOC
15.2.  Mandatory to Implement Features for Dynamic OpenID Providers
In addition to the features listed above, OpenID Providers supporting dynamic establishment of relationships with RPs that they do not have a pre-configured relationship with MUST also implement the following features defined in this and related specifications.


Response Types
These OpenID Providers MUST support the id_token Response Type and all that are not Self-Issued OPs MUST also support the code and id_token token Response Types.
Discovery
These OPs MUST support Discovery, as defined in OpenID Connect Discovery 1.0 [OpenID.Discovery].
Dynamic Registration
These OPs MUST support Dynamic Client Registration, as defined in OpenID Connect Dynamic Client Registration 1.0 [OpenID.Registration].
UserInfo Endpoint
All dynamic OPs that issue Access Tokens MUST support the UserInfo Endpoint, as defined in Section 5.3. (Self-Issued OPs do not issue Access Tokens.)
Public Keys Published as Bare Keys
These OPs MUST publish their public keys as bare JWK keys (which MAY also be accompanied by X.509 representations of those keys).
Request URI
These OPs MUST support requests made using a Request Object value that is retrieved from a Request URI that is provided with the request_uri parameter, as defined in Section 6.2.


 TOC
15.3.  Discovery and Registration
Some OpenID Connect installations can use a pre-configured set of OpenID Providers and/or Relying Parties. In those cases, it might not be necessary to support dynamic discovery of information about identities or services or dynamic registration of Clients.

However, if installations choose to support unanticipated interactions between Relying Parties and OpenID Providers that do not have pre-configured relationships, they SHOULD accomplish this by implementing the facilities defined in the OpenID Connect Discovery 1.0 [OpenID.Discovery] and OpenID Connect Dynamic Client Registration 1.0 [OpenID.Registration] specifications.


 TOC
15.4.  Mandatory to Implement Features for Relying Parties
In general, it is up to Relying Parties which features they use when interacting with OpenID Providers. However, some choices are dictated by the nature of their OAuth Client, such as whether it is a Confidential Client, capable of keeping secrets, in which case the Authorization Code Flow may be appropriate, or whether it is a Public Client, for instance, a User Agent Based Application or a statically registered Native Application, in which case the Implicit Flow may be appropriate.

When using OpenID Connect features, those listed as being "REQUIRED" or are described with a "MUST" are mandatory to implement, when used by a Relying Party. Likewise, those features that are described as "OPTIONAL" need not be used or supported unless they provide value in the particular application context. Finally, when interacting with OpenID Providers that support Discovery, the OP's Discovery document can be used to dynamically determine which OP features are available for use by the RP.



 TOC
15.5.  Implementation Notes

 TOC
15.5.1.  Authorization Code Implementation Notes
When using the Authorization Code or Hybrid flows, an ID Token is returned from the Token Endpoint in response to a Token Request using an Authorization Code. Some implementations may choose to encode state about the ID Token to be returned in the Authorization Code value. Others may use the Authorization Code value as an index into a database storing this state.


 TOC
15.5.2.  Nonce Implementation Notes
The nonce parameter value needs to include per-session state and be unguessable to attackers. One method to achieve this for Web Server Clients is to store a cryptographically random value as an HttpOnly session cookie and use a cryptographic hash of the value as the nonce parameter. In that case, the nonce in the returned ID Token is compared to the hash of the session cookie to detect ID Token replay by third parties. A related method applicable to JavaScript Clients and other Browser-Based Clients is to store the cryptographically random value in HTML5 local storage and use a cryptographic hash of this value.


 TOC
15.5.3.  Redirect URI Fragment Handling Implementation Notes
When response parameters are returned in the Redirection URI fragment value, the Client needs to have the User Agent parse the fragment encoded values and pass them to on to the Client's processing logic for consumption. User Agents that have direct access to cryptographic APIs may be able to be self-contained, for instance, with all Client code being written in JavaScript.

However, if the Client does not run entirely in the User Agent, one way to achieve this is to post them to a Web Server Client for validation.

The following is an example of a JavaScript file that a Client might host at its redirect_uri. This is loaded by the redirect from the Authorization Server. The fragment component is parsed and then sent by POST to a URI that will validate and use the information received.

Following is a non-normative example of a Redirect URI response:

  GET /cb HTTP/1.1
  Host: client.example.org

  HTTP/1.1 200 OK
  Content-Type: text/html

  <script type="text/javascript">

  // First, parse the query string
  var params = {}, postBody = location.hash.substring(1),
      regex = /([^&=]+)=([^&]*)/g, m;
  while (m = regex.exec(postBody)) {
    params[decodeURIComponent(m[1])] = decodeURIComponent(m[2]);
  }

  // And send the token over to the server
  var req = new XMLHttpRequest();
  // using POST so query isn't logged
  req.open('POST', 'https://' + window.location.host +
                   '/catch_response', true);
  req.setRequestHeader('Content-Type',
                       'application/x-www-form-urlencoded');

  req.onreadystatechange = function (e) {
    if (req.readyState == 4) {
      if (req.status == 200) {
  // If the response from the POST is 200 OK, perform a redirect
        window.location = 'https://'
          + window.location.host + '/redirect_after_login'
      }
  // if the OAuth response is invalid, generate an error message
      else if (req.status == 400) {
        alert('There was an error processing the token')
      } else {
        alert('Something other than 200 was returned')
      }
    }
  };
  req.send(postBody);

 TOC
15.6.  Compatibility Notes
NOTE: Potential compatibility issues that were previously described in the original version of this specification have since been addressed.


 TOC
15.7.  Related Specifications and Implementer's Guides
These related OPTIONAL specifications MAY be used in combination with this specification to provide additional functionality:

OpenID Connect Discovery 1.0 [OpenID.Discovery] - Defines how Relying Parties dynamically discover information about OpenID Providers
OpenID Connect Dynamic Client Registration 1.0 [OpenID.Registration] - Defines how Relying Parties dynamically register with OpenID Providers
OAuth 2.0 Form Post Response Mode [OAuth.Post] - Defines how to return OAuth 2.0 Authorization Response parameters (including OpenID Connect Authentication Response parameters) using HTML form values that are auto-submitted by the User Agent using HTTP POST
OpenID Connect RP-Initiated Logout 1.0 [OpenID.RPInitiated] - Defines how a Relying Party requests that an OpenID Provider log out the End-User
OpenID Connect Session Management 1.0 [OpenID.Session] - Defines how to manage OpenID Connect sessions, including postMessage-based logout and RP-initiated logout functionality
OpenID Connect Front-Channel Logout 1.0 [OpenID.FrontChannel] - Defines a front-channel logout mechanism that does not use an OP iframe on RP pages
OpenID Connect Back-Channel Logout 1.0 [OpenID.BackChannel] - Defines a logout mechanism that uses direct back-channel communication between the OP and RPs being logged out

These implementer's guides are intended to serve as self-contained references for implementers of basic Web-based Relying Parties:

OpenID Connect Basic Client Implementer's Guide 1.0 [OpenID.Basic] - Implementer's guide containing a subset of this specification that is intended for use by basic Web-based Relying Parties using the OAuth Authorization Code Flow
OpenID Connect Implicit Client Implementer's Guide 1.0 [OpenID.Implicit] - Implementer's guide containing a subset of this specification that is intended for use by basic Web-based Relying Parties using the OAuth Implicit Flow


 TOC
16.  Security Considerations
This specification references the security considerations defined in Section 10 of OAuth 2.0 [RFC6749], and Section 5 of OAuth 2.0 Bearer Token Usage [RFC6750]. Furthermore, the OAuth 2.0 Threat Model and Security Considerations [RFC6819] specification provides an extensive list of threats and controls that apply to this specification as well, given that it is based upon OAuth 2.0. ISO/IEC 29115 [ISO29115] also provides threats and controls that implementers need to take into account. Implementers are highly advised to read these references in detail and apply the countermeasures described therein.

In addition, the following list of attack vectors and remedies are also considered.


 TOC
16.1.  Request Disclosure
If appropriate measures are not taken, a request might be disclosed to an attacker, posing security and privacy threats.

In addition to what is stated in Section 5.1.1 of [RFC6819], this standard provides a way to provide the confidentiality of the request end to end through the use of request or request_uri parameters, where the content of the request is an encrypted JWT with the appropriate key and cipher. This protects even against a compromised User Agent in the case of indirect request.


 TOC
16.2.  Server Masquerading
A malicious Server might masquerade as the legitimate server using various means. To detect such an attack, the Client needs to authenticate the server.

In addition to what is stated in Section 5.1.2 of [RFC6819], this standard provides a way to authenticate the Server through either the use of Signed or Encrypted JWTs with an appropriate key and cipher.


 TOC
16.3.  Token Manufacture/Modification
An Attacker might generate a bogus token or modify the token contents (such as Claims values or the signature) of an existing parseable token, causing the RP to grant inappropriate access to the Client. For example, an Attacker might modify the parseable token to extend the validity period; a Client might modify the parseable token to have access to information that they should not be able to view.

There are two ways to mitigate this attack:


The token can be digitally signed by the OP. The Relying Party SHOULD validate the digital signature to verify that it was issued by a legitimate OP.
The token can be sent over a protected channel such as TLS. See Section 16.17 for more information on using TLS. In this specification, the token is always sent over a TLS protected channel. Note however, that this measure is only a defense against third party attackers and is not applicable to the case where the Client is the attacker.


 TOC
16.4.  Access Token Disclosure
Access Tokens are credentials used to access Protected Resources, as defined in Section 1.4 of OAuth 2.0 [RFC6749]. Access Tokens represent an End-User's authorization and MUST NOT be exposed to unauthorized parties.


 TOC
16.5.  Server Response Disclosure
The server response might contain authentication data and Claims that include sensitive Client information. Disclosure of the response contents can make the Client vulnerable to other types of attacks.

The server response disclosure can be mitigated in the following two ways:

Using the code Response Type. The response is sent over a TLS protected channel, where the Client is authenticated by the client_id and client_secret.
For other Response Types, the signed response can be encrypted with the Client's public key or a shared secret as an encrypted JWT with an appropriate key and cipher.


 TOC
16.6.  Server Response Repudiation
A response might be repudiated by the server if the proper mechanisms are not in place. For example, if a Server does not digitally sign a response, the Server can claim that it was not generated through the services of the Server.

To mitigate this threat, the response MAY be digitally signed by the Server using a key that supports non-repudiation. The Client SHOULD validate the digital signature to verify that it was issued by a legitimate Server and its integrity is intact.


 TOC
16.7.  Request Repudiation
Since it is possible for a compromised or malicious Client to send a request to the wrong party, a Client that was authenticated using only a bearer token can repudiate any transaction.

To mitigate this threat, the Server MAY require that the request be digitally signed by the Client using a key that supports non-repudiation. The Server SHOULD validate the digital signature to verify that it was issued by a legitimate Client and its integrity is intact.


 TOC
16.8.  Access Token Redirect
An Attacker uses the Access Token generated for one resource to obtain access to a second resource.

To mitigate this threat, the Access Token SHOULD be audience and scope restricted. One way of implementing it is to include the identifier of the resource for whom it was generated as audience. The resource verifies that incoming tokens include its identifier as the audience of the token.


 TOC
16.9.  Token Reuse
An Attacker attempts to use a one-time use token such as an Authorization Code that has already been used once with the intended Resource. To mitigate this threat, the token SHOULD include a timestamp and a short validity lifetime. The Relying Party then checks the timestamp and lifetime values to ensure that the token is currently valid.

Alternatively, the server MAY record the state of the use of the token and check the status for each request.


 TOC
16.10.  Eavesdropping or Leaking Authorization Codes (Secondary Authenticator Capture)
In addition to the attack patterns described in Section 4.4.1.1 of [RFC6819], an Authorization Code can be captured in the User Agent where the TLS session is terminated if the User Agent is infected by malware. However, capturing it is not useful as long as either Client Authentication or an encrypted response is used.


 TOC
16.11.  Token Substitution
Token Substitution is a class of attacks in which a malicious user swaps various tokens, including swapping an Authorization Code for a legitimate user with another token that the attacker has. One means of accomplishing this is for the attacker to copy a token out one session and use it in an HTTP message for a different session, which is easy to do when the token is available to the browser; this is known as the "cut and paste" attack.

The Implicit Flow of OAuth 2.0 [RFC6749] is not designed to mitigate this risk. In Section 10.16, it normatively requires that any use of the authorization process as a form of delegated End-User authentication to the Client MUST NOT use the Implicit Flow without employing additional security mechanisms that enable the Client to determine whether the ID Token and Access Token were issued for its use.

In OpenID Connect, this is mitigated through mechanisms provided through the ID Token. The ID Token is a signed security token that provides Claims such as iss (issuer), sub (subject), aud (audience), at_hash (access token hash), and c_hash (code hash). Using the ID Token, the Client is capable of detecting the Token Substitution Attack.

The c_hash in the ID Token enables Clients to prevent Authorization Code substitution. The at_hash in the ID Token enables Clients to prevent Access Token substitution.

Also, a malicious user may attempt to impersonate a more privileged user by subverting the communication channel between the Authorization Endpoint and Client, or the Token Endpoint and Client, for example by swapping the Authorization Code or reordering the messages, to convince the Token Endpoint that the attacker's authorization grant corresponds to a grant sent on behalf of a more privileged user.

For the HTTP binding defined by this specification, the responses to Token Requests are bound to the corresponding requests by message order in HTTP, as both the response containing the token and requests are protected by TLS, which will detect and prevent packet reordering.

When designing another binding of this specification to a protocol incapable of strongly binding Token Endpoint requests to responses, additional mechanisms to address this issue MUST be utilized. One such mechanism could be to include an ID Token with a c_hash Claim in the token request and response.


 TOC
16.12.  Timing Attack
A timing attack enables the attacker to obtain an unnecessary large amount of information through the elapsed time differences in the code paths taken by successful and unsuccessful decryption operations or successful and unsuccessful signature validation of a message. It can be used to reduce the effective key length of the cipher used.

Implementations SHOULD NOT terminate the validation process at the instant of the finding an error but SHOULD continue running until all the octets have been processed to avoid this attack.


 TOC
16.13.  Other Crypto Related Attacks
There are various crypto related attacks possible depending on the method used for encryption and signature / integrity checking. Implementers need to consult the Security Considerations for the JWT [JWT] specification and specifications that it references to avoid the vulnerabilities identified in these specifications.


 TOC
16.14.  Signing and Encryption Order
Signatures over encrypted text are not considered valid in many jurisdictions. Therefore, for integrity and non-repudiation, this specification requires signing the plain text JSON Claims, when signing is performed. If both signing and encryption are desired, it is performed on the JWS containing the signed Claims, with the result being a Nested JWT, as specified in [JWT]. Note that since all JWE encryption algorithms provide integrity protection, there is no need to separately sign the encrypted content.


 TOC
16.15.  Issuer Identifier
OpenID Connect supports multiple Issuers per Host and Port combination. The issuer returned by discovery MUST exactly match the value of iss in the ID Token.

OpenID Connect treats the path component of any Issuer URI as being part of the Issuer Identifier. For instance, the subject "1234" with an Issuer Identifier of "https://example.com" is not equivalent to the subject "1234" with an Issuer Identifier of "https://example.com/sales".

It is RECOMMENDED that only a single Issuer per host be used. However, if a host supports multiple tenants, multiple Issuers for that host may be needed.


 TOC
16.16.  Implicit Flow Threats
In the Implicit Flow, the Access Token is returned in the fragment component of the Client's redirect_uri through HTTPS, thus it is protected between the OP and the User Agent, and between the User Agent and the RP. The only place it can be captured is the User Agent where the TLS session is terminated, which is possible if the User Agent is infected by malware or under the control of a malicious party.


 TOC
16.17.  TLS Requirements
Implementations MUST support TLS. Which version(s) ought to be implemented will vary over time and depend on the widespread deployment and known security vulnerabilities at the time of implementation. Implementations SHOULD follow the guidance in BCP 195 [RFC8996] [RFC9325], which provides recommendations and requirements for improving the security of deployed services that use TLS.

To protect against information disclosure and tampering, confidentiality protection MUST be applied using TLS with a ciphersuite that provides confidentiality and integrity protection.

Whenever TLS is used, a TLS server certificate check MUST be performed, per RFC 6125 [RFC6125].


 TOC
16.18.  Lifetimes of Access Tokens and Refresh Tokens
Access Tokens might not be revocable by the Authorization Server. Access Token lifetimes SHOULD therefore be kept to single use or very short lifetimes.

If ongoing access to the UserInfo Endpoint or other Protected Resources is required, a Refresh Token can be used. The Client can then exchange the Refresh Token at the Token Endpoint for a fresh short-lived Access Token that can be used to access the resource.

The Authorization Server SHOULD clearly identify long-term grants to the User during Authorization. The Authorization Server SHOULD provide a mechanism for the End-User to revoke Access Tokens and Refresh Tokens granted to a Client.


 TOC
16.19.  Symmetric Key Entropy
In Section 10.1 and Section 10.2, keys are derived from the client_secret value. Thus, when used with symmetric signing or encryption operations, client_secret values MUST contain sufficient entropy to generate cryptographically strong keys. Also, client_secret values MUST also contain at least the minimum of number of octets required for MAC keys for the particular algorithm used. So for instance, for HS256, the client_secret value MUST contain at least 32 octets (and almost certainly SHOULD contain more, since client_secret values are likely to use a restricted alphabet).


 TOC
16.20.  Need for Signed Requests
In some situations, Clients might need to use signed requests to ensure that the desired request parameters are delivered to the OP without having been tampered with. For instance, the max_age and acr_values provide more assurance about the nature of the authentication performed when delivered in signed requests.


 TOC
16.21.  Need for Encrypted Requests
In some situations, knowing the contents of an OpenID Connect request can, in and of itself, reveal sensitive information about the End-User. For instance, knowing that the Client is requesting a particular Claim or that it is requesting that a particular authentication method be used can reveal sensitive information about the End-User. OpenID Connect enables requests to be encrypted to the OpenID Provider to prevent such potentially sensitive information from being revealed.


 TOC
16.22.  HTTP 307 Redirects
HTTP 307 redirects send a POST request to the party being redirected to that contains all the form data from the previous request. This can leak credentials intended for the OpenID Provider to the Relying Party. Therefore, HTTP 307 redirects MUST NOT be used when redirecting to the Redirection URI. Likewise, while HTTP 302 redirects are typically implemented in a way that does not do this, the use of HTTP 303 redirect is preferable, as it is defined not to do this.


 TOC
16.23.  Custom URI Schemes on iOS
Note that on iOS, multiple applications can register as handlers for a custom URI scheme, therefore it is not deterministic that the calling application will receive the Authentication Reply from the Self-Issued OpenID Provider. Use of a claimed URI is an alternative to using the openid: custom URI scheme.

While it is possible to assign handlers to custom URI schemes and it is possible that the operating system could help the End-User select the correct handler, it is not possible to guarantee that the handler for a given custom URI scheme has not been replaced by a subsequently installed native application. At the time of this writing, there appears to be no fool-proof mitigation for this vulnerability.


 TOC
17.  Privacy Considerations

 TOC
17.1.  Personally Identifiable Information
The UserInfo Response typically contains Personally Identifiable Information (PII). As such, End-User consent for the release of the information for the specified purpose should be obtained at or prior to the authorization time in accordance with relevant regulations. The purpose of use is typically registered in association with the redirect_uris.

Only necessary UserInfo data should be stored at the Client and the Client SHOULD associate the received data with the purpose of use statement.


 TOC
17.2.  Data Access Monitoring
The Resource Server SHOULD make End-Users' UserInfo access logs available to them so that they can monitor who accessed their data.


 TOC
17.3.  Correlation
To protect the End-User from possible correlation among Clients, the use of a Pairwise Pseudonymous Identifier (PPID) as the sub (subject) SHOULD be considered.


 TOC
17.4.  Offline Access
Offline access enables access to Claims when the user is not present, posing greater privacy risk than the Claims transfer when the user is present. Therefore, it is prudent to obtain explicit consent for offline access to resources. This specification mandates the use of the prompt parameter to obtain consent unless it is already known that the request complies with the conditions for processing the request in each jurisdiction.

When an Access Token is returned via the User Agent using the Implicit Flow or Hybrid Flow, there is a greater risk of it being exposed to an attacker, who could later use it to access the UserInfo endpoint. If the Access Token does not enable offline access and the server can differentiate whether the Client request has been made offline or online, the risk will be substantially reduced. Therefore, this specification mandates ignoring the offline access request when the Access Token is transmitted through the User Agent. Note that differentiating between online and offline access from the server can be difficult especially for native clients. The server may well have to rely on heuristics. Also, the risk of exposure for the Access Token delivered through the User Agent for the Response Types of code token and token is the same. Thus, the implementations should be prepared to detect whether the Access Token was issued through the User Agent or directly from the Token Endpoint and deny offline access if the token was issued through the User Agent.

Note that although these provisions require an explicit consent dialogue through the prompt parameter, the mere fact that the user pressed an "accept" button etc., might not constitute a valid consent. Developers should be aware that for the act of consent to be valid, typically, the impact of the terms have to be understood by the End-User, the consent must be freely given and not forced (i.e., other options have to be available), and the terms must fair and equitable. In general, it is advisable for the service to follow the required privacy principles in each jurisdiction and rely on other conditions for processing the request than simply explicit consent, as online self-service "explicit consent" often does not form a valid consent in some jurisdictions.


 TOC
18.  IANA Considerations

 TOC
18.1.  JSON Web Token Claims Registration
This specification registers the following Claims in the IANA "JSON Web Token Claims" registry [IANA.JWT.Claims] established by [JWT].


 TOC
18.1.1.  Registry Contents

Claim Name: name
Claim Description: Full name
Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification Document(s): Section 5.1 of this specification


Claim Name: given_name
Claim Description: Given name(s) or first name(s)
Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification Document(s): Section 5.1 of this specification


Claim Name: family_name
Claim Description: Surname(s) or last name(s)
Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification Document(s): Section 5.1 of this specification


Claim Name: middle_name
Claim Description: Middle name(s)
Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification Document(s): Section 5.1 of this specification


Claim Name: nickname
Claim Description: Casual name
Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification Document(s): Section 5.1 of this specification


Claim Name: preferred_username
Claim Description: Shorthand name by which the End-User wishes to be referred to
Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification Document(s): Section 5.1 of this specification


Claim Name: profile
Claim Description: Profile page URL
Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification Document(s): Section 5.1 of this specification


Claim Name: picture
Claim Description: Profile picture URL
Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification Document(s): Section 5.1 of this specification


Claim Name: website
Claim Description: Web page or blog URL
Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification Document(s): Section 5.1 of this specification


Claim Name: email
Claim Description: Preferred e-mail address
Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification Document(s): Section 5.1 of this specification


Claim Name: email_verified
Claim Description: True if the e-mail address has been verified; otherwise false
Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification Document(s): Section 5.1 of this specification


Claim Name: gender
Claim Description: Gender
Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification Document(s): Section 5.1 of this specification


Claim Name: birthdate
Claim Description: Birthday
Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification Document(s): Section 5.1 of this specification


Claim Name: zoneinfo
Claim Description: Time zone
Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification Document(s): Section 5.1 of this specification


Claim Name: locale
Claim Description: Locale
Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification Document(s): Section 5.1 of this specification


Claim Name: phone_number
Claim Description: Preferred telephone number
Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification Document(s): Section 5.1 of this specification


Claim Name: phone_number_verified
Claim Description: True if the phone number has been verified; otherwise false
Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification Document(s): Section 5.1 of this specification


Claim Name: address
Claim Description: Preferred postal address
Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification Document(s): Section 5.1 of this specification


Claim Name: updated_at
Claim Description: Time the information was last updated
Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification Document(s): Section 5.1 of this specification


Claim Name: azp
Claim Description: Authorized party - the party to which the ID Token was issued
Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification Document(s): Section 2 of this specification


Claim Name: nonce
Claim Description: Value used to associate a Client session with an ID Token
Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification Document(s): Section 2 of this specification


Claim Name: auth_time
Claim Description: Time when the authentication occurred
Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification Document(s): Section 2 of this specification


Claim Name: at_hash
Claim Description: Access Token hash value
Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification Document(s): Section 2 of this specification


Claim Name: c_hash
Claim Description: Code hash value
Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification Document(s): Section 3.3.2.11 of this specification


Claim Name: acr
Claim Description: Authentication Context Class Reference
Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification Document(s): Section 2 of this specification


Claim Name: amr
Claim Description: Authentication Methods References
Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification Document(s): Section 2 of this specification


Claim Name: sub_jwk
Claim Description: Public key used to check the signature of an ID Token
Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification Document(s): Section 7.4 of this specification


Claim Name: _claim_names
Claim Description: JSON object whose member names are the Claim Names for the Aggregated and Distributed Claims
Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification Document(s): Section 5.6.2 of this specification


Claim Name: _claim_sources
Claim Description: JSON object whose member names are referenced by the member values of the _claim_names member
Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification Document(s): Section 5.6.2 of this specification


 TOC
18.2.  OAuth Parameters Registration
This specification registers the following parameters in the IANA "OAuth Parameters" registry [IANA.OAuth.Parameters] established by RFC 6749 [RFC6749].


 TOC
18.2.1.  Registry Contents

Parameter name: nonce
Parameter usage location: Authorization Request
Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification document(s): Section 3.1.2 of this specification
Related information: None


Parameter name: display
Parameter usage location: Authorization Request
Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification document(s): Section 3.1.2 of this specification
Related information: None


Parameter name: prompt
Parameter usage location: Authorization Request
Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification document(s): Section 3.1.2 of this specification
Related information: None


Parameter name: max_age
Parameter usage location: Authorization Request
Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification document(s): Section 3.1.2 of this specification
Related information: None


Parameter name: ui_locales
Parameter usage location: Authorization Request
Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification document(s): Section 3.1.2 of this specification
Related information: None


Parameter name: claims_locales
Parameter usage location: Authorization Request
Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification document(s): Section 5.2 of this specification
Related information: None


Parameter name: id_token_hint
Parameter usage location: Authorization Request
Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification document(s): Section 3.1.2 of this specification
Related information: None


Parameter name: login_hint
Parameter usage location: Authorization Request
Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification document(s): Section 3.1.2 of this specification
Related information: None


Parameter name: acr_values
Parameter usage location: Authorization Request
Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification document(s): Section 3.1.2 of this specification
Related information: None


Parameter name: claims
Parameter usage location: Authorization Request
Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification document(s): Section 5.5 of this specification
Related information: None


Parameter name: registration
Parameter usage location: Authorization Request
Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification document(s): Section 7.2.1 of this specification
Related information: None


Parameter name: request
Parameter usage location: Authorization Request
Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification document(s): Section 6 of this specification
Related information: None


Parameter name: request_uri
Parameter usage location: Authorization Request
Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification document(s): Section 6 of this specification
Related information: None


Parameter name: id_token
Parameter usage location: Authorization Response, Access Token Response
Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification document(s): Section 3.1.3.3 of this specification
Related information: None


 TOC
18.3.  OAuth Extensions Error Registration
This specification registers the following errors in the IANA "OAuth Extensions Error" registry [IANA.OAuth.Parameters] established by RFC 6749 [RFC6749].


 TOC
18.3.1.  Registry Contents

Error name: interaction_required
Error usage location: Authorization Endpoint
Related protocol extension: OpenID Connect
Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification document(s): Section 3.1.2.6 of this specification


Error name: login_required
Error usage location: Authorization Endpoint
Related protocol extension: OpenID Connect
Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification document(s): Section 3.1.2.6 of this specification


Error name: account_selection_required
Error usage location: Authorization Endpoint
Related protocol extension: OpenID Connect
Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification document(s): Section 3.1.2.6 of this specification


Error name: consent_required
Error usage location: Authorization Endpoint
Related protocol extension: OpenID Connect
Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification document(s): Section 3.1.2.6 of this specification


Error name: invalid_request_uri
Error usage location: Authorization Endpoint
Related protocol extension: OpenID Connect
Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification document(s): Section 3.1.2.6 of this specification


Error name: invalid_request_object
Error usage location: Authorization Endpoint
Related protocol extension: OpenID Connect
Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification document(s): Section 3.1.2.6 of this specification


Error name: request_not_supported
Error usage location: Authorization Endpoint
Related protocol extension: OpenID Connect
Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification document(s): Section 3.1.2.6 of this specification


Error name: request_uri_not_supported
Error usage location: Authorization Endpoint
Related protocol extension: OpenID Connect
Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification document(s): Section 3.1.2.6 of this specification


Error name: registration_not_supported
Error usage location: Authorization Endpoint
Related protocol extension: OpenID Connect
Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
Specification document(s): Section 3.1.2.6 of this specification


 TOC
18.4.  URI Scheme Registration
This specification registers the following URI scheme in the IANA "Uniform Resource Identifier (URI) Schemes" registry [IANA.URISchemes] established by RFC 7595 [RFC7595].


 TOC
18.4.1.  Registry Contents

Scheme name: openid
Status: Permanent
Applications/protocols that use this scheme name: OpenID Connect
Contact: Michael B. Jones - michael_b_jones@hotmail.com
Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
References: Section 7.3 of this specification


 TOC
19.  References

 TOC
19.1. Normative References
[CORS]	Opera Software ASA, “Cross-Origin Resource Sharing,” July 2010.
[E.164]	International Telecommunication Union, “E.164: The international public telecommunication numbering plan,” 2010.
[IANA.AMR]	IANA, “Authentication Method Reference Values.”
[IANA.JWT.Claims]	IANA, “JSON Web Token Claims.”
[IANA.Language]	IANA, “Language Subtag Registry.”
[IANA.OAuth.Parameters]	IANA, “OAuth Parameters.”
[IANA.URISchemes]	IANA, “Uniform Resource Identifier (URI) Schemes.”
[IANA.time-zones]	IANA, “Time Zone Database.”
[ISO29115]	International Organization for Standardization, “ISO/IEC 29115:2013. Information technology - Security techniques - Entity authentication assurance framework,” ISO/IEC 29115:2013, April 2013.
[ISO3166-1]	International Organization for Standardization, “ISO 3166-1:2020. Codes for the representation of names of countries and their subdivisions - Part 1: Country codes,” August 2020.
[ISO639]	International Organization for Standardization, “ISO 639:2023. Code for individual languages and language groups,” November 2023.
[ISO8601-1]	International Organization for Standardization, “ISO 8601-1:2019/Amd 1:2022. Date and time - Representations for information interchange - Part 1: Basic rules,” October 2022.
[JWA]	Jones, M., “JSON Web Algorithms (JWA),” RFC 7518, DOI 10.17487/RFC7518, May 2015.
[JWE]	Jones, M. and J. Hildebrand, “JSON Web Encryption (JWE),” RFC 7516, DOI 10.17487/RFC7516, May 2015.
[JWK]	Jones, M., “JSON Web Key (JWK),” RFC 7517, DOI 10.17487/RFC7517, May 2015.
[JWS]	Jones, M., Bradley, J., and N. Sakimura, “JSON Web Signature (JWS),” RFC 7515, DOI 10.17487/RFC7515, May 2015.
[JWT]	Jones, M., Bradley, J., and N. Sakimura, “JSON Web Token (JWT),” RFC 7519, DOI 10.17487/RFC7519, May 2015.
[OAuth.Assertions]	Campbell, B., Mortimore, C., Jones, M., and Y. Goland, “Assertion Framework for OAuth 2.0 Client Authentication and Authorization Grants,” RFC 7521, DOI 10.17487/RFC7521, May 2015.
[OAuth.JWT]	Jones, M., Campbell, B., and C. Mortimore, “JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants,” RFC 7523, DOI 10.17487/RFC7523, May 2015.
[OAuth.Responses]	de Medeiros, B., Ed., Scurtescu, M., Tarjan, P., and M. Jones, “OAuth 2.0 Multiple Response Type Encoding Practices,” February 2014.
[OpenID.Discovery]	Sakimura, N., Bradley, J., Jones, M., and E. Jay, “OpenID Connect Discovery 1.0,” December 2023.
[OpenID.Registration]	Sakimura, N., Bradley, J., and M. Jones, “OpenID Connect Dynamic Client Registration 1.0,” December 2023.
[RFC20]	Cerf, V., “ASCII format for Network Interchange,” STD 80, RFC 20, DOI 10.17487/RFC0020, October 1969.
[RFC2119]	Bradner, S., “Key words for use in RFCs to Indicate Requirement Levels,” BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.
[RFC3339]	Klyne, G. and C. Newman, “Date and Time on the Internet: Timestamps,” RFC 3339, DOI 10.17487/RFC3339, July 2002.
[RFC3629]	Yergeau, F., “UTF-8, a transformation format of ISO 10646,” STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003.
[RFC3966]	Schulzrinne, H., “The tel URI for Telephone Numbers,” RFC 3966, DOI 10.17487/RFC3966, December 2004.
[RFC3986]	Berners-Lee, T., Fielding, R., and L. Masinter, “Uniform Resource Identifier (URI): Generic Syntax,” STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005.
[RFC5322]	Resnick, P., Ed., “Internet Message Format,” RFC 5322, DOI 10.17487/RFC5322, October 2008.
[RFC5646]	Phillips, A., Ed. and M. Davis, Ed., “Tags for Identifying Languages,” BCP 47, RFC 5646, DOI 10.17487/RFC5646, September 2009.
[RFC6125]	Saint-Andre, P. and J. Hodges, “Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS),” RFC 6125, DOI 10.17487/RFC6125, March 2011.
[RFC6711]	Johansson, L., “An IANA Registry for Level of Assurance (LoA) Profiles,” RFC 6711, DOI 10.17487/RFC6711, August 2012.
[RFC6749]	Hardt, D., Ed., “The OAuth 2.0 Authorization Framework,” RFC 6749, DOI 10.17487/RFC6749, October 2012.
[RFC6750]	Jones, M. and D. Hardt, “The OAuth 2.0 Authorization Framework: Bearer Token Usage,” RFC 6750, DOI 10.17487/RFC6750, October 2012.
[RFC6819]	Lodderstedt, T., Ed., McGloin, M., and P. Hunt, “OAuth 2.0 Threat Model and Security Considerations,” RFC 6819, DOI 10.17487/RFC6819, January 2013.
[RFC7230]	Fielding, R., Ed. and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing,” RFC 7230, DOI 10.17487/RFC7230, June 2014.
[RFC7231]	Fielding, R., Ed. and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content,” RFC 7231, DOI 10.17487/RFC7231, June 2014.
[RFC7234]	Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Caching,” RFC 7234, DOI 10.17487/RFC7234, June 2014.
[RFC8176]	Jones, M., Hunt, P., and A. Nadalin, “Authentication Method Reference Values,” RFC 8176, DOI 10.17487/RFC8176, June 2017.
[RFC8259]	Bray, T., Ed., “The JavaScript Object Notation (JSON) Data Interchange Format,” STD 90, RFC 8259, DOI 10.17487/RFC8259, December 2017.
[RFC8996]	Moriarty, K. and S. Farrell, “Deprecating TLS 1.0 and TLS 1.1,” BCP 195, RFC 8996, DOI 10.17487/RFC8996, March 2021.
[RFC9325]	Sheffer, Y., Saint-Andre, P., and T. Fossati, “Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS),” BCP 195, RFC 9325, DOI 10.17487/RFC9325, November 2022.
[UNICODE]	The Unicode Consortium, “The Unicode Standard.”
[USA15]	Whistler, K., “Unicode Normalization Forms,” Unicode Standard Annex 15, August 2023.
[W3C.SPSD-html401-20180327]	“HTML 4.01 Specification,” W3C REC SPSD-html401-20180327, W3C SPSD-html401-20180327, March 2018.

 TOC
19.2. Informative References
[JWK.Thumbprint]	Jones, M. and N. Sakimura, “JSON Web Key (JWK) Thumbprint,” RFC 7638, DOI 10.17487/RFC7638, September 2015.
[OAuth.Post]	Jones, M. and B. Campbell, “OAuth 2.0 Form Post Response Mode,” April 2015.
[OpenID.2.0]	OpenID Foundation, “OpenID Authentication 2.0,” December 2007.
[OpenID.BackChannel]	Jones, M. and J. Bradley, “OpenID Connect Back-Channel Logout 1.0,” December 2023.
[OpenID.Basic]	Sakimura, N., Bradley, J., Jones, M., de Medeiros, B., and C. Mortimore, “OpenID Connect Basic Client Implementer's Guide 1.0,” December 2023.
[OpenID.Core.Errata1]	Sakimura, N., Bradley, J., Jones, M., de Medeiros, B., and C. Mortimore, “OpenID Connect Core 1.0 incorporating errata set 1,” November 2014.
[OpenID.Core.Final]	Sakimura, N., Bradley, J., Jones, M., de Medeiros, B., and C. Mortimore, “OpenID Connect Core 1.0 (final),” February 2014.
[OpenID.FrontChannel]	Jones, M., “OpenID Connect Front-Channel Logout 1.0,” September 2022.
[OpenID.Implicit]	Sakimura, N., Bradley, J., Jones, M., de Medeiros, B., and C. Mortimore, “OpenID Connect Implicit Client Implementer's Guide 1.0,” December 2023.
[OpenID.PAPE]	Recordon, D., Jones, M., Bufu, J., Ed., Daugherty, J., Ed., and N. Sakimura, “OpenID Provider Authentication Policy Extension 1.0,” December 2008.
[OpenID.RPInitiated]	Jones, M., de Medeiros, B., Agarwal, N., Sakimura, N., and J. Bradley, “OpenID Connect RP-Initiated Logout 1.0,” September 2022.
[OpenID.Session]	de Medeiros, B., Agarwal, N., Sakimura, N., Bradley, J., and M. Jones, “OpenID Connect Session Management 1.0,” September 2022.
[RFC4949]	Shirey, R., “Internet Security Glossary, Version 2,” FYI 36, RFC 4949, DOI 10.17487/RFC4949, August 2007.
[RFC7595]	Thaler, D., Ed., Hansen, T., and T. Hardie, “Guidelines and Registration Procedures for URI Schemes,” BCP 35, RFC 7595, DOI 10.17487/RFC7595, June 2015.
[RFC9101]	Sakimura, N., Bradley, J., and M. Jones, “The OAuth 2.0 Authorization Framework: JWT-Secured Authorization Request (JAR),” RFC 9101, DOI 10.17487/RFC9101, August 2021.
[X.1252]	International Telecommunication Union, “ITU-T Recommendation X.1252 - Cyberspace security - Identity management - Baseline identity management terms and definitions,” ITU-T X.1252, April 2010.

 TOC
Appendix A.  Authorization Examples
The following are non-normative examples of Authorization Requests with different response_type values and their responses (with line wraps within values for display purposes only):


 TOC
A.1.  Example using response_type=code
  GET /authorize?
    response_type=code
    &client_id=s6BhdRkqt3
    &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb
    &scope=openid%20profile%20email
    &nonce=n-0S6_WzA2Mj
    &state=af0ifjsldkj HTTP/1.1
  Host: server.example.com

  HTTP/1.1 302 Found
  Location: https://client.example.org/cb?
    code=Qcb0Orv1zh30vL1MPRsbm-diHiMwcLyZvn1arpZv-Jxf_11jnpEX3Tgfvk
    &state=af0ifjsldkj

 TOC
A.2.  Example using response_type=id_token
  GET /authorize?
    response_type=id_token
    &client_id=s6BhdRkqt3
    &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb
    &scope=openid%20profile%20email
    &nonce=n-0S6_WzA2Mj
    &state=af0ifjsldkj HTTP/1.1
  Host: server.example.com

  HTTP/1.1 302 Found
  Location: https://client.example.org/cb#
    id_token=eyJraWQiOiIxZTlnZGs3IiwiYWxnIjoiUlMyNTYifQ.
    ewogImlzcyI6ICJodHRwczovL3NlcnZlci5leGFtcGxlLmNvbSIsCiAic3ViIjog
    IjI0ODI4OTc2MTAwMSIsCiAiYXVkIjogInM2QmhkUmtxdDMiLAogIm5vbmNlIjog
    Im4tMFM2X1d6QTJNaiIsCiAiZXhwIjogMTMxMTI4MTk3MCwKICJpYXQiOiAxMzEx
    MjgwOTcwLAogIm5hbWUiOiAiSmFuZSBEb2UiLAogImdpdmVuX25hbWUiOiAiSmFu
    ZSIsCiAiZmFtaWx5X25hbWUiOiAiRG9lIiwKICJnZW5kZXIiOiAiZmVtYWxlIiwK
    ICJiaXJ0aGRhdGUiOiAiMDAwMC0xMC0zMSIsCiAiZW1haWwiOiAiamFuZWRvZUBl
    eGFtcGxlLmNvbSIsCiAicGljdHVyZSI6ICJodHRwOi8vZXhhbXBsZS5jb20vamFu
    ZWRvZS9tZS5qcGciCn0.
    NTibBYW_ZoNHGm4ZrWCqYA9oJaxr1AVrJCze6FEcac4t_EOQiJFbD2nVEPkUXPuM
    shKjjTn7ESLIFUnfHq8UKTGibIC8uqrBgQAcUQFMeWeg-PkLvDTHk43Dn4_aNrxh
    mWwMNQfkjqx3wd2Fvta9j8yG2Qn790Gwb5psGcmBhqMJUUnFrGpyxQDhFIzzodmP
    okM7tnUxBNj-JuES_4CE-BvZICH4jKLp0TMu-WQsVst0ss-vY2RPdU1MzL59mq_e
    Kk8Rv9XhxIr3WteA2ZlrgVyT0cwH3hlCnRUsLfHtIEb8k1Y_WaqKUu3DaKPxqRi6
    u0rN7RO2uZYPzC454xe-mg
    &state=af0ifjsldkj
The value of the id_token parameter is the ID Token, which is a signed JWT, containing three base64url-encoded segments separated by period ('.') characters. The first segment represents the JOSE Header. Base64url decoding it will result in the following set of Header Parameters:

  {"kid":"1e9gdk7","alg":"RS256"}
The alg value represents the algorithm that was used to sign the JWT, in this case RS256, representing RSASSA-PKCS1-v1_5 using SHA-256. The kid value is a key identifier used in identifying the key to be used to verify the signature. If the kid value is unknown to the RP, it needs to retrieve the contents of the OP's JWK Set again to obtain the OP's current set of keys.

The second segment represents the Claims in the ID Token. Verifying and decoding the ID Token will yield the following Claims:

  {
   "iss": "https://server.example.com",
   "sub": "248289761001",
   "aud": "s6BhdRkqt3",
   "nonce": "n-0S6_WzA2Mj",
   "exp": 1311281970,
   "iat": 1311280970,
   "name": "Jane Doe",
   "given_name": "Jane",
   "family_name": "Doe",
   "gender": "female",
   "birthdate": "0000-10-31",
   "email": "janedoe@example.com",
   "picture": "http://example.com/janedoe/me.jpg"
  }
The third segment represents the ID Token signature, which is verified as described in [JWS].


 TOC
A.3.  Example using response_type=id_token token
  GET /authorize?
    response_type=id_token%20token
    &client_id=s6BhdRkqt3
    &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb
    &scope=openid%20profile%20email
    &nonce=n-0S6_WzA2Mj
    &state=af0ifjsldkj HTTP/1.1
  Host: server.example.com

  HTTP/1.1 302 Found
  Location: https://client.example.org/cb#
    access_token=jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y
    &token_type=Bearer
    &id_token=eyJraWQiOiIxZTlnZGs3IiwiYWxnIjoiUlMyNTYifQ.
    ewogImlzcyI6ICJodHRwczovL3NlcnZlci5leGFtcGxlLmNvbSIsCiAic3ViIjog
    IjI0ODI4OTc2MTAwMSIsCiAiYXVkIjogInM2QmhkUmtxdDMiLAogIm5vbmNlIjog
    Im4tMFM2X1d6QTJNaiIsCiAiZXhwIjogMTMxMTI4MTk3MCwKICJpYXQiOiAxMzEx
    MjgwOTcwLAogImF0X2hhc2giOiAiNzdRbVVQdGpQZnpXdEYyQW5wSzlSUSIKfQ.
    kdqTmftlaXg5WBYBr1wkxhkqCGZPc0k8vTiV5g2jj67jQ7XkrDamYx2bOkZLdZrp
    MPIzkdYB1nZI_G8vQGQuamRhJcEIt21kblGPZ-yhEhdkAiZIZLu38rChalDS2Mh0
    glE_rke5XXRhmqqoEFFdziFdnO3p61-7y51co84OEAZvARSINQaOWIzvioRfs4zw
    IFOaT33Vpxfqr8HDyh31zo9eBW2dSQuCa071z0ENWChWoPliK1JCo_Bk9eDg2uwo
    2ZwhsvHzj6TMQ0lYOTzufSlSmXIKfjlOsb3nftQeR697_hA-nMZyAdL8_NRfaC37
    XnAbW8WB9wCfECp7cuNuOg
    &state=af0ifjsldkj
Verifying and decoding the ID Token will yield the following Claims:

  {
   "iss": "https://server.example.com",
   "sub": "248289761001",
   "aud": "s6BhdRkqt3",
   "nonce": "n-0S6_WzA2Mj",
   "exp": 1311281970,
   "iat": 1311280970,
   "at_hash": "77QmUPtjPfzWtF2AnpK9RQ"
  }

 TOC
A.4.  Example using response_type=code id_token
  GET /authorize?
    response_type=code%20id_token
    &client_id=s6BhdRkqt3
    &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb
    &scope=openid%20profile%20email
    &nonce=n-0S6_WzA2Mj
    &state=af0ifjsldkj HTTP/1.1
  Host: server.example.com

  HTTP/1.1 302 Found
  Location: https://client.example.org/cb#
    code=Qcb0Orv1zh30vL1MPRsbm-diHiMwcLyZvn1arpZv-Jxf_11jnpEX3Tgfvk
    &id_token=eyJraWQiOiIxZTlnZGs3IiwiYWxnIjoiUlMyNTYifQ.
    ewogImlzcyI6ICJodHRwczovL3NlcnZlci5leGFtcGxlLmNvbSIsCiAic3ViIjog
    IjI0ODI4OTc2MTAwMSIsCiAiYXVkIjogInM2QmhkUmtxdDMiLAogIm5vbmNlIjog
    Im4tMFM2X1d6QTJNaiIsCiAiZXhwIjogMTMxMTI4MTk3MCwKICJpYXQiOiAxMzEx
    MjgwOTcwLAogImNfaGFzaCI6ICJMRGt0S2RvUWFrM1BrMGNuWHhDbHRBIgp9.
    MRPihYtNIcwKTZ_mcMSPfreVytGR4jfl1Tzbv4tH5Jr4WqONs2lUWrIEpZ2joKbZ
    fAGlouAqwqSYpfR3FQYKYvdgnZ3kjIJ_5M4fAARXHVSciGyhfqB-OhDUMXSHzFHi
    GKNY9TKSgRfiXf_314WRujpqaDtj2uoXbppobYXvAZIxWtsOein0-t91LDS39EW4
    frNWAopKTBBi_XJPlpLVynWTDvNleEBP6UxIMgYJBKlqsP7RGfHTGk3ReXDacR7R
    GZlIVGa-0qRyDzvNqD7xfu9aYufUP0oBGqdBGgFVNmwJ7rmB0gdPtC2eJsXq9svC
    gBBfhRQZxhx1iLJjNc9nSw
    &state=af0ifjsldkj
Verifying and decoding the ID Token will yield the following Claims:

  {
   "iss": "https://server.example.com",
   "sub": "248289761001",
   "aud": "s6BhdRkqt3",
   "nonce": "n-0S6_WzA2Mj",
   "exp": 1311281970,
   "iat": 1311280970,
   "c_hash": "LDktKdoQak3Pk0cnXxCltA"
  }

 TOC
A.5.  Example using response_type=code token
  GET /authorize?
    response_type=code%20token
    &client_id=s6BhdRkqt3
    &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb
    &scope=openid%20profile%20email
    &nonce=n-0S6_WzA2Mj
    &state=af0ifjsldkj HTTP/1.1
  Host: server.example.com

  HTTP/1.1 302 Found
  Location: https://client.example.org/cb#
    code=Qcb0Orv1zh30vL1MPRsbm-diHiMwcLyZvn1arpZv-Jxf_11jnpEX3Tgfvk
    &access_token=jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y
    &token_type=Bearer
    &state=af0ifjsldkj

 TOC
A.6.  Example using response_type=code id_token token
  GET /authorize?
    response_type=code%20id_token%20token
    &client_id=s6BhdRkqt3
    &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb
    &scope=openid%20profile%20email
    &nonce=n-0S6_WzA2Mj
    &state=af0ifjsldkj HTTP/1.1
  Host: server.example.com

  HTTP/1.1 302 Found
  Location: https://client.example.org/cb#
    code=Qcb0Orv1zh30vL1MPRsbm-diHiMwcLyZvn1arpZv-Jxf_11jnpEX3Tgfvk
    &access_token=jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y
    &token_type=Bearer
    &id_token=eyJraWQiOiIxZTlnZGs3IiwiYWxnIjoiUlMyNTYifQ.
    ewogImlzcyI6ICJodHRwczovL3NlcnZlci5leGFtcGxlLmNvbSIsCiAic3ViIjog
    IjI0ODI4OTc2MTAwMSIsCiAiYXVkIjogInM2QmhkUmtxdDMiLAogIm5vbmNlIjog
    Im4tMFM2X1d6QTJNaiIsCiAiZXhwIjogMTMxMTI4MTk3MCwKICJpYXQiOiAxMzEx
    MjgwOTcwLAogImF0X2hhc2giOiAiNzdRbVVQdGpQZnpXdEYyQW5wSzlSUSIsCiAi
    Y19oYXNoIjogIkxEa3RLZG9RYWszUGswY25YeENsdEEiCn0.
    A2OhhJzbUNaCbNLqNaqetGLJoxB3ujVbq_HLYSOWgWCJ3-B__YxlqIg8gpeL0Vhv
    rWX0mwz7w_pGTRN4JdgsI0xAlT5fob1ZPnrazgonSyzaXcg2bgD896SsBSlG_8JX
    6JKaztXifn8k2gy65Me-sMyQrRF8xv_q1CeC871sZpMjJzy5nx65BTI17vcXjntZ
    HADv6o2CrHrEdHp8xSlnTLiiIqgDOmKlpkeqqOBK6dqa4rXZlSqMAUm1LYZmtb2D
    8sHvQsxTbWlBkX7VZaTSqMJ487s4ZIEea8Bw4KGVOntQue4VhBjBnQ4bQKhB_47D
    xlWpSyOWdy3cer_zxKrfvw
    &state=af0ifjsldkj
Verifying and decoding the ID Token will yield the following Claims:

  {
   "iss": "https://server.example.com",
   "sub": "248289761001",
   "aud": "s6BhdRkqt3",
   "nonce": "n-0S6_WzA2Mj",
   "exp": 1311281970,
   "iat": 1311280970,
   "at_hash": "77QmUPtjPfzWtF2AnpK9RQ",
   "c_hash": "LDktKdoQak3Pk0cnXxCltA"
  }

 TOC
A.7.  RSA Key Used in Examples
The following RSA public key, represented in JWK format, can be used to validate the ID Token signatures in the above examples (with line wraps within values for display purposes only):

  {
   "kty":"RSA",
   "kid":"1e9gdk7",
   "n":"w7Zdfmece8iaB0kiTY8pCtiBtzbptJmP28nSWwtdjRu0f2GFpajvWE4VhfJA
        jEsOcwYzay7XGN0b-X84BfC8hmCTOj2b2eHT7NsZegFPKRUQzJ9wW8ipn_aD
        JWMGDuB1XyqT1E7DYqjUCEOD1b4FLpy_xPn6oV_TYOfQ9fZdbE5HGxJUzeku
        GcOKqOQ8M7wfYHhHHLxGpQVgL0apWuP2gDDOdTtpuld4D2LK1MZK99s9gaSj
        RHE8JDb1Z4IGhEcEyzkxswVdPndUWzfvWBBWXWxtSUvQGBRkuy1BHOa4sP6F
        KjWEeeF7gm7UMs2Nm2QUgNZw6xvEDGaLk4KASdIxRQ",
   "e":"AQAB"
  }

 TOC
Appendix B.  Acknowledgements
As a successor version of OpenID, this specification heavily relies on ideas explored in OpenID Authentication 2.0 [OpenID.2.0]. Please refer to Appendix C of OpenID Authentication 2.0 for the full list of the contributors for that specification.

In addition, the OpenID Community would like to thank the following people for their contributions to this specification:


Naveen Agarwal (Naveen.Agarwal@microsoft.com), Microsoft (was at Google)

Amanda Anganes (aanganes@mitre.org), MITRE

Casper Biering (cb@peercraft.com), Peercraft

John Bradley (ve7jtb@ve7jtb.com), Yubico (was at Ping Identity)

Tim Bray (tbray@textuality.com), independent (was at Google)

Johnny Bufu (johnny.bufu@gmail.com), independent (was at Janrain)

Brian Campbell (bcampbell@pingidentity.com), Ping Identity

Blaine Cook (romeda@gmail.com), independent

Breno de Medeiros (breno@google.com), Google

Pamela Dingle (Pamela.Dingle@microsoft.com), Microsoft (was at Ping Identity)

Vladimir Dzhuvinov (vladimir@connect2id.com), Connect2id (was at Nimbus Directory Services)

George Fletcher (gffletch@aol.com), Capital One (was at AOL)

Roland Hedberg (roland@catalogix.se), independent (was at University of Umeå)

Ryo Ito (ryo.ito@mixi.co.jp), mixi, Inc.

Edmund Jay (ejay@mgi1.com), Illumila

Michael B. Jones (michael_b_jones@hotmail.com), Self-Issued Consulting (was at Microsoft)

Torsten Lodderstedt (torsten@lodderstedt.net), independent (was at Deutsche Telekom)

James Manger (James.H.Manger@team.telstra.com), Telstra

Nov Matake (nov@matake.jp), independent

Chuck Mortimore (charliemortimore@gmail.com), Disney (was at Salesforce)

Anthony Nadalin (nadalin@prodigy.net), independent (was at Microsoft)

Hideki Nara (hdknr@ic-tact.co.jp), Tact Communications

Axel Nennker (axel.nennker@telekom.de), Deutsche Telekom

David Recordon (recordond@gmail.com), independent (was at Facebook)

Justin Richer (justin@bspk.io), Bespoke Engineering (was at MITRE)

Nat Sakimura (nat@nat.consulting), NAT.Consulting (was at NRI)

Luke Shepard (luke@lukeshepard.com), Facebook

Andreas Åkre Solberg (Andreas.Solberg@sikt.no), Sikt (was at UNINET)

Paul Tarjan (paul@paultarjan.com), Facebook



 TOC
Appendix C.  Notices
Copyright (c) 2023 The OpenID Foundation.

The OpenID Foundation (OIDF) grants to any Contributor, developer, implementer, or other interested party a non-exclusive, royalty free, worldwide copyright license to reproduce, prepare derivative works from, distribute, perform and display, this Implementers Draft or Final Specification solely for the purposes of (i) developing specifications, and (ii) implementing Implementers Drafts and Final Specifications based on such documents, provided that attribution be made to the OIDF as the source of the material, but that such attribution does not indicate an endorsement by the OIDF.

The technology described in this specification was made available from contributions from various sources, including members of the OpenID Foundation and others. Although the OpenID Foundation has taken steps to help ensure that the technology is available for distribution, it takes no position regarding the validity or scope of any intellectual property or other rights that might be claimed to pertain to the implementation or use of the technology described in this specification or the extent to which any license under such rights might or might not be available; neither does it represent that it has made any independent effort to identify any such rights. The OpenID Foundation and the contributors to this specification make no (and hereby expressly disclaim any) warranties (express, implied, or otherwise), including implied warranties of merchantability, non-infringement, fitness for a particular purpose, or title, related to this specification, and the entire risk as to implementing this specification is assumed by the implementer. The OpenID Intellectual Property Rights policy requires contributors to offer a patent promise not to assert certain patent claims against other contributors and against implementers. The OpenID Foundation invites any interested party to bring to its attention any copyrights, patents, patent applications, or other proprietary rights that may cover technology that may be required to practice this specification.


 TOC
Authors' Addresses
 	Nat Sakimura
 	NAT.Consulting
Email: 	nat@nat.consulting
URI: 	https://nat.sakimura.org/

 	John Bradley
 	Yubico
Email: 	ve7jtb@ve7jtb.com
URI: 	http://www.thread-safe.com/

 	Michael B. Jones
 	Self-Issued Consulting
Email: 	michael_b_jones@hotmail.com
URI: 	https://self-issued.info/

 	Breno de Medeiros
 	Google
Email: 	breno@google.com
URI: 	https://stackoverflow.com/users/311376/breno

 	Chuck Mortimore
 	Disney
Email: 	charliemortimore@gmail.com
URI: 	https://twitter.com/cmort